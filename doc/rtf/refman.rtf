{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment TaskManager  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2.0 \par
}}TaskManager}
{\comment Generated by doxygen 1.9.4.}
{\creatim \yr2022\mo6\dy2\hr16\min0\sec5}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt TaskManager}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 2.0\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Thu Jun 2 2022 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
TaskManger - Cooperative Multitasking System for Arduino\par \pard\plain 
{\tc \v TaskManger - Cooperative Multitasking System for Arduino}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Overview
\par}
{\tc\tcl2 \v Overview}
{\b TaskManager} is a cooperative task manager for the Arduino family of processors. It replaces the single user {\f2 loop()}  routine with an environment in which the user can write many independent {\f2 loop()}  -style routines. These user routines are run in a round-robin manner. In addition, routines can {
\par\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Delay \'96 suspending their operation for a specified period while allowing other routines to make use of the time \par\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Signal \'96 suspend action until they receive a signal, or send a signal allowing a different task to resume \par\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Message \'96 suspend action until a message has been received, or send messages to different tasks to pass them information.\par
}
\par}
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
News
\par}
{\tc\tcl2 \v News}
2022/05/31: Release 2.0: Merging Atmel and ESP32 branches. \par
 \par
ESP32 will include multi-node (mesh) routines to send/receive messages between nodes. Atmel systems will need to use TaskManagerRF version 2.0 to support this functionality. 2015/11/13: Release 1.0: Initial full release. \par
More code cleanup, improved documentation. Added routines so tasks could ID where messages/signals came from. may be a while until they are...\par}
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Summary
\par}
{\tc\tcl2 \v Summary}
{\b TaskManager} is a cooperative multitasking task-swapper. It allows the developer to create many independent tasks, which are called in a round-robin manner. \par
{\b TaskManager} offers the following: {
\par\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Any number of tasks. \par\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Extends the Arduino "setup/loop" paradigm \'96 the programmer creates several "loop" routines (tasks) instead of one. So programming is simple and straightforward. \par\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Tasks can communicate through signals or messages. A signal is an information-free "poke" sent to whatever task is waiting for the poke. A message has information (string or data), and is passed to a particular task. \par\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TaskManager} programs can use RF24 2.4GHz radios to communicate between nodes. So tasks running on different nodes can communicate through signals and messages in the same manner as if they were on the same node.\par
}
\par}
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Example
\par}
{\tc\tcl2 \v Example}
The following is a {\b TaskManager} program. {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf20 //}\par
{\cf20 // Blink two LEDs at different rates}\par
{\cf20 //}\par
\par
{\cf21 #include <SPI.h>}\par
{\cf21 #include <RF24.h>}\par
{\cf21 #include <TaskManager.h>}\par
\par
{\cf21 #define LED_1_PORT  2}\par
{\cf18 bool} led_1_state;\par
\par
{\cf21 #define LED_2_PORT  3}\par
{\cf18 bool} led_2_state;\par
\par
{\cf18 void} setup() \{\par
  pinMode(LED_1_PORT, OUTPUT);\par
  digitalWrite(LED_1_PORT, LOW);\par
  led_1_state = LOW;\par
\par
  pinMode(LED_2_PORT, OUTPUT);\par
  digitalWrite(LED_2_PORT, LOW);\par
  led_2_state = LOW;\par
\par
  TaskMgr.add(1, loop_led_1);\par
  TaskMgr.add(2, loop_led_2);\par
\}\par
\par
{\cf18 void} loop_led_1() \{\par
    led_1_state = (led_1_state==LOW) ? HIGH : LOW;\par
    digitalWrite(LED_1_PORT, led_1_state);\par
    TaskMgr.yieldDelay(500);\par
\}\par
\par
{\cf18 void} loop_led_2() \{\par
    led_2_state = (led_2_state==LOW) ? HIGH : LOW;\par
    digitalWrite(LED_2_PORT, led_2_state);\par
    TaskMgr.yieldDelay(100);\par
\}\par
}
\par
Note the following; this is all that is needed for {\b TaskManager}: {
\par\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
You need to '#include <TaskManager.h>'. \par\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
There is no 'void loop()'. Instead, you write a routine for each independent task as if it were its own 'loop()'. \par\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
You tell 'TaskMgr' about your routines through the 'void TaskManager::add(byte
    taskId, void (*) task);' method. This is shown in the two calls to 'TaskMgr.add(...);'. \par\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
You do not use 'delay();'. Never use 'delay();'. 'delay();' delays all things; nothing will run. Instead use {\b TaskManager::yieldDelay()}'. 'yieldDelay()' will return from the current routine and guarantee it won't be restarted for the specified time. However, other routines will be allowed to run during this time.\par
}
\par}
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Future Work
\par}
{\tc\tcl2 \v Future Work}
Here are the upcoming/future plans for {\b TaskManager}. Some are short term, some are longer term. {
\par\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SPI investigation/certification. Running RF in a multi-SPI environment is "fraught with peril". The SPI routines {\f2 beginTransaction()}  and {\f2 endTransaction()}  allow different SPI devices to share the MOSI/MISO interface even if they use different serial settings. However, most SPI libraries do not use currently use these routines. (Note that the RF library recommended for {\b TaskManager} does.) We need to investigate the different SPI libraries and identify the transaction-safety of each. \par\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Suspend, resume, and kill. These routines haven't been fully tested. \par
}
\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Module Index\par \pard\plain 
{\tc \v Module Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Modules\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all modules:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Ring\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
TaskManager\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
TaskManagerTask\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b _ring} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements a templated ring data structure })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ring< T >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An STL-style class that implements rings })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TaskManager} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A cooperative multitasking manager })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all documented files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b TaskManager_2.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TaskManagerBoilerplates_2.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TaskManagerCore_2.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TaskManagerMacros_2.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TaskManagerSub_2.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Module Documentation{\tc \v Module Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ring\par \pard\plain 
{\tc\tcl2 \v Ring}
{\xe \v Ring}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ring< T >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An STL-style class that implements rings. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b _ring}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements a templated ring data structure. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TaskManager\par \pard\plain 
{\tc\tcl2 \v TaskManager}
{\xe \v TaskManager}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TaskManager}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A cooperative multitasking manager. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

#define {\b TASKMGR_RF_MONITOR_TASK}\~ (TASKMGR_NULL_TASK-1){\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

#define {\b TASKMGR_PING_MONITOR_TASK}\~ (TASKMGR_NULL_TASK-2){\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

#define {\b TASKMGR_MENU_MONITOR_TASK}\~ (TASKMGR_NULL_TASK-3){\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Miscellaneous and Informational Routines\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
tm_taskId_t {\b TaskManager::myId} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the task ID of the currently running task. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v myId\:TaskManager}
{\xe \v TaskManager\:myId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
tm_taskId_t TaskManager::myId (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the task ID of the currently running task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The byte value that represents the current task's ID. \par
}}}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TaskManagerTask\par \pard\plain 
{\tc\tcl2 \v TaskManagerTask}
{\xe \v TaskManagerTask}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
_ring Class Reference\par \pard\plain 
{\tc\tcl2 \v _ring}
{\xe \v _ring}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements a templated ring data structure. }}\par
{
{\f2 #include <TaskManagerCore_2.h>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements a templated ring data structure. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a templated class that implements a ring of arbitrary objects. Each object must have a constructor and a destructor as well as operator=. It should also have the printTo member function if any form of serialization is to be done.\par
This implements ring traversal (move to next/prev), insertion/deletion, etc. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
TaskManagerCore_2.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ring< T > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v ring< T >}
{\xe \v ring< T >}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An STL-style class that implements rings. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ring} (){\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct an empty ring. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~ring} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroy a ring. }{
}\par
}\par}
}
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push_front} (T val)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Push an element onto the front of the ring. The element will be the new current element. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push_back} (T val)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Push an element onto the back of the ring. The current element is left unchanged. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pop_front} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the first element from the ring. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pop_back} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the last element from the ring. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all elements from a ring. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T & {\b front} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the first stored data element. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T & {\b back} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the last stored data element. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b move_next} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Moves the ring to the next element in sequence. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b move_prev} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Moves the ring to the previous element in sequence. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b empty} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tells whether or not a ring is empty. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the size of the ring. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ring}< T > & {\b operator=} ({\b ring}< T > &r)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Produces a lightweight assignnment/copy of a ring. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} ({\b ring}< T > &r) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compare two rings for equality. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b map} (void(*fn)(T &))\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Map a function across each data element on a ring. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b map} (void(*fn)(T &, void *), void *)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Map a function with one secondary parameter across all of the elements of a ring. }{
}\par
}\par}
}
}{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class T>\par
class ring< T >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An STL-style class that implements rings. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ~ring\:ring< T >}
{\xe \v ring< T >\:~ring}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > {\b ring}< T >::~{\b ring} (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroy a ring. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
As part of this process, the destructors for all of the stored objects will be called. After the destruction, the ring will be empty. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v back\:ring< T >}
{\xe \v ring< T >\:back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > T & {\b ring}< T >::back{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the last stored data element. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This returns a reference to the last stored data element. Any changes to this will change the referenced (on-ring) value as well. Calling on an empty ring will result in unpredictable actions. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b front} \par
}}}}
{\xe \v clear\:ring< T >}
{\xe \v ring< T >\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void {\b ring}< T >::clear}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all elements from a ring. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes all elements from a ring. This will call the destructor of all stored objects. Calling on an empty ring will have no effect. The ring will be empty after this is called. Returns nothing. \par
}}
{\xe \v empty\:ring< T >}
{\xe \v ring< T >\:empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > bool {\b ring}< T >::empty{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tells whether or not a ring is empty. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the ring is empty, false if the ring has values on it. \par
}}
{\xe \v front\:ring< T >}
{\xe \v ring< T >\:front}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > T & {\b ring}< T >::front{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the first stored data element. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This returns a reference to the first stored data element. Any changes to this will change the referenced (on-ring) value as well. Calling on an empty ring will result in unpredictable actions. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b back} \par
}}}}
{\xe \v map\:ring< T >}
{\xe \v ring< T >\:map}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void {\b ring}< T >::map (void(*)(T &)  {\i fn})}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Map a function across each data element on a ring. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Map a function that takes a single T as its param. T is passed as a reference so the function may modify T. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fn} \cell }{- The function to be applied to each element. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b map}(void ({\i fn)(T&, void} ), void*) \par
}}}}
{\xe \v map\:ring< T >}
{\xe \v ring< T >\:map}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void {\b ring}< T >::map (void(*)(T &, void *)  {\i fn}, void *  {\i p})}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Map a function with one secondary parameter across all of the elements of a ring. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Map a function that takes a T and a void* as a param. T is pased as a reference so the function may modify T. The void* is a parameter to map and is passed to the function. It may be a pointer to anything, and can be used to accumulate results, etc. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fn} \cell }{- A function that takes a ring's data object and an arbitrary data pointer. The function is applied to the pair. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p} \cell }{- An arbitrary data object. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b map}(void (*fn)()) \par
}}}}
{\xe \v move_next\:ring< T >}
{\xe \v ring< T >\:move_next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void {\b ring}< T >::move_next{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Moves the ring to the next element in sequence. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This moves the ring to the next element in sequence. If the ring is empty (or has only one member), it will be unchanged. The previous first element will now be the last element. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b move_prev} \par
}}}}
{\xe \v move_prev\:ring< T >}
{\xe \v ring< T >\:move_prev}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void {\b ring}< T >::move_prev{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Moves the ring to the previous element in sequence. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This moves the ring to the previous element in sequence. If the ring is empty (or has only one member), it will be unchanged. The previous last element will now be the first element. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b move_next} \par
}}}}
{\xe \v operator=\:ring< T >}
{\xe \v ring< T >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > {\b ring}< T > & {\b ring}< T >::operator= ({\b ring}< T > &  {\i r}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Produces a lightweight assignnment/copy of a ring. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Produces a lightweight copy of the ring. That is, the top level data of the ring is copied, but all of the data nodes are shared between the source and destination ring. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i r} \cell }{- the ring that is to be "copied" \cell }
{\row }
}
}}
{\xe \v operator==\:ring< T >}
{\xe \v ring< T >\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > bool {\b ring}< T >::operator== ({\b ring}< T > &  {\i r}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compare two rings for equality. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compares the two rings. This is a lightweight comparion. It compares the top level data (are they pointing to the same data components), but does not compare data components. As such, two rings separately constructed with the same data values will not be equal. But two rings constructed with the operator= will (provided neither have been modified {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i r} \cell }{- the ring that the current ring is being compared against. \cell }
{\row }
}
}}
{\xe \v pop_back\:ring< T >}
{\xe \v ring< T >\:pop_back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void {\b ring}< T >::pop_back{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the last element from the ring. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the last element from the ring. This will call the destructor of the stored object. Calling on an empty ring will have no effect. Returns nothing. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b pop_front()} \par
}}}}
{\xe \v pop_front\:ring< T >}
{\xe \v ring< T >\:pop_front}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void {\b ring}< T >::pop_front}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the first element from the ring. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the first element from the ring. This will call the destructor of the stored object. Calling on an empty ring will have no effect. Returns nothing. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b pop_back()} \par
}}}}
{\xe \v push_back\:ring< T >}
{\xe \v ring< T >\:push_back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void {\b ring}< T >::push_back (T  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Push an element onto the back of the ring. The current element is left unchanged. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Places the element at the front of the ring. All other elements in the ring are preserved. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i val} \cell }{- The object being pushed onto the back. The object is copied. As such, the object will require a copier (operator=) member function. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b back()}, {\b push_front()}; \par
}}}}
{\xe \v push_front\:ring< T >}
{\xe \v ring< T >\:push_front}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void {\b ring}< T >::push_front (T  {\i val})}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Push an element onto the front of the ring. The element will be the new current element. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Places the element at the front of the ring. All other elements in the ring are preserved. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i val} \cell }{- The object being pushed onto the front. The object is copied. As such, the object will require a copier (operator=) member function. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b front()}, {\b push_back()} \par
}}}}
{\xe \v size\:ring< T >}
{\xe \v ring< T >\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > size_t {\b ring}< T >::size}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the size of the ring. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of elements in the ring. Returns 0 for an empty ring. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
TaskManagerCore_2.h\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TaskManager Class Reference\par \pard\plain 
{\tc\tcl2 \v TaskManager}
{\xe \v TaskManager}
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A cooperative multitasking manager. }}\par
{
{\f2 #include <TaskManagerCore_2.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TaskManager} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, Creates an empty task. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~TaskManager} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. Destroys the {\b TaskManager}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b loop} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements a single pass for the system {\b loop()} routine. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
_TaskManagerTask * {\b findTaskById} (tm_taskId_t id)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Find a task by its ID. }{
}\par
}\par}
}
{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Adding a New Task\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
These methods are used to add new tasks to the task list \par
}}\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add} (tm_taskId_t taskId, void(*fn)())\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a simple task. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addWaitDelay} (tm_taskId_t taskId, void(*fn)(), unsigned long msDelay)\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a task that will be delayed before its first invocation. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addWaitUntil} (tm_taskId_t taskId, void(*fn)(), unsigned long msWhen)\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a task that will be delayed until a set system clock time before its first invocation. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addWaitMessage} (tm_taskId_t taskId, void(*fn)(), unsigned long timeout=0)\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a task that is waiting for a message. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addAutoWaitDelay} (tm_taskId_t taskId, void(*fn)(), unsigned long period, bool startDelayed=false)\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a task that will automatically reschedule itself with a delay. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addAutoWaitMessage} (tm_taskId_t taskId, void(*fn)(), unsigned long timeout=0, bool startWaiting=true)\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a task that is waiting for a message or until a timeout occurs. }{
}\par
}\par}
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Yield\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
These methods are used to yield control back to the task manager core. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Upon next invocation, execution will start at the TOP of the routine, not at the statement following the yield. \par
A {\i yield}  call will override any of the {\i addAuto...}  automatic rescheduling. This will be a one-time override; later (non-{\i yield} ) returns will resume automatic rescheduling. \par
}}}}\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b yield} ()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exit from this task and return control to the task manager. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b yieldDelay} (unsigned long ms)\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exit from the task manager and do not restart this task until after a specified period. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b yieldUntil} (unsigned long when)\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exit from the task manager and do not restart this task until (after) a specified CPU clock time. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b yieldForMessage} (unsigned long timeout=0)\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exit from the task manager and do not restart this task until a message has been received or a stated time period has passed. }{
}\par
}\par}
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Sending Messages\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
These methods send messages to other tasks running on this or other nodes \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
If the nodeID is 0 on any routine that sends messages to other nodes, the signal/message will be sent to this node. \par
}}}}\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sendMessage} (tm_taskId_t taskId, char *message)\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sends a string message to a task. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sendMessage} (tm_taskId_t taskId, void *buf, int len)\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Send a binary message to a task. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b sendMessage} (tm_nodeId_t nodeId, tm_taskId_t taskId, char *message)\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sends a string message to a task. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getSource} (tm_taskId_t &fromTaskId)\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get task ID of last message/signal. }{
}\par
}\par}
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Task Management\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Change task types\par
These routines change the scheduling metod for the given task. FOr example, SetAutoWaitDelay() will change a task so it will automatically wait for the set delay period after yielding (instead of using whatever rescheduling process was defined when it was Add()ed).\par
The change will take place immediately. If it is being performed on the currernt task, it will impact the next yield/return. If it is performed on a suspended task, the suspended tasks's reawakening constraints will be reset to the new method. \par
}}\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b suspend} (tm_taskId_t taskId)\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Suspend the given task on this node. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resume} (tm_taskId_t taskId)\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resume the given task on this node. }{
}\par
}\par}
}
}{
\pard\plain \s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid Miscellaneous and Informational Routines\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

unsigned long {\b runtime} () const{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the time since the start of the run, in milliseconds. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b timedOut} ()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tell if the current task has timed out while waiting for a signal or message. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b getMessage} ()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a task's message buffer. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b getMessageLength} ()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the length of the message in the buffer. }{
}\par
}\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
tm_taskId_t {\b myId} ()\par
{
\pard\plain \s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the task ID of the currently running task. }{
}\par
}\par}
}
}\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

{\b ring}< _TaskManagerTask > {\b m_theTasks}{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The ring of all tasks. For internal use only. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b internalSendMessage} (tm_nodeId_t fromNodeId, tm_taskId_t fromTaskId, tm_taskId_t taskId, char *message){\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 

void {\b internalSendMessage} (tm_nodeId_t fromNodeId, tm_taskId_t fromTaskId, tm_taskId_t taskId, void *buf, int len){\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A cooperative multitasking manager. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Manages a set of cooperative tasks. This includes round-robin scheduling, yielding, and inter-task messaging and signaling. It also replaces the {\b loop()} function in standard Arduino programs. Nominally, there is a single instance of {\b TaskManager} called TaskMgr. TaskMgr is used for all actual task control.\par
Each task has a taskID. By convention, user tasks' taskID values are in the range [0 127]. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v TaskManager\:TaskManager}
{\xe \v TaskManager\:TaskManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TaskManager::TaskManager ()}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor, Creates an empty task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Print out information about the task. \par
}}
{\xe \v ~TaskManager\:TaskManager}
{\xe \v TaskManager\:~TaskManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TaskManager::~TaskManager ()}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. Destroys the {\b TaskManager}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
After calling this, any operations based on the object will fail. For normal purpoases, destroying the TaskMgr instance will have serious consequences for the standard {\b loop()} routine. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v add\:TaskManager}
{\xe \v TaskManager\:add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TaskManager::add (tm_taskId_t  {\i taskId}, void(*)()  {\i fn})}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a simple task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The task will execute once each cycle through the task list. Unless the task itself forces itself into a different scheduling model (e.g., through YieldSignal), it will execute again at the next available opportunity {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i taskId} \cell }{- the task's ID. For normal user tasks, this should be a byte value in the range [1 239]. System tasks have taskId values in the range [240 255]. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fn} \cell }{\'96 this is a void function with no arguments. This is the procedure that is called every time the task is invoked. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b addWaitDelay}, {\b addWaitUntil}, {\b addAutoWaitDelay} \par
}}}}
{\xe \v addAutoWaitDelay\:TaskManager}
{\xe \v TaskManager\:addAutoWaitDelay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TaskManager::addAutoWaitDelay (tm_taskId_t  {\i taskId}, void(*)()  {\i fn}, unsigned long  {\i period}, bool  {\i startDelayed} = {\f2 false})}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a task that will automatically reschedule itself with a delay. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This task will execute once each cycle. The task will automatically reschedule itself to not execute until the given delay has passed. The first execution may be delayed using the optional fourth parameter startDelayed. This delay, if used, will be the same as the period.\par
Note that yielding for messages or signals may extend this delay. However, if a signal/message is received during the delay period., the procedure will still wait until the end of the delay period. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i taskId} \cell }{- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fn} \cell }{\'96 this is a void function with no arguments. This is the procedure that is called every time the task is invoked. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i period} \cell }{\'96 the schedule, in milliseconds \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i startDelayed} \cell }{\'96 for the first execution, start immediately (false), or delay its start for one period (true) \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b add}, addDelayed, {\b addWaitUntil} \par
}}}}
{\xe \v addAutoWaitMessage\:TaskManager}
{\xe \v TaskManager\:addAutoWaitMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TaskManager::addAutoWaitMessage (tm_taskId_t  {\i taskId}, void(*)()  {\i fn}, unsigned long  {\i timeout} = {\f2 0}, bool  {\i startWaiting} = {\f2 true})}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a task that is waiting for a message or until a timeout occurs. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The task will be added, but will be set to be waiting for the listed signal. If the signal does not arrive before the timeout period (in milliseconds), then the routine will be activated. The routine may use {\b TaskManager::timedOut()} to determine whether it timed our or received the signal. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i taskId} \cell }{- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fn} \cell }{\'96 this is a void function with no arguments. This is the procedure that is called every time the task is invoked. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i timeout} \cell }{\'96 the maximum time to wait (in ms) before timing out. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i startWaiting} \cell }{\'96 tells whether the routine will start waiting for the signal (true) or will execute immediately (false). \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b addWaitMessage} \par
}}}}
{\xe \v addWaitDelay\:TaskManager}
{\xe \v TaskManager\:addWaitDelay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TaskManager::addWaitDelay (tm_taskId_t  {\i taskId}, void(*)()  {\i fn}, unsigned long  {\i msDelay})}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a task that will be delayed before its first invocation. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This task will execute once each cycle. Its first execution will be delayed for a set time. After this, unless the task forces itself into a different scheduling model (e.g., through yieldSignal), it will execute agaion at the next available opportunity. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i taskId} \cell }{- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fn} \cell }{\'96 this is a void function with no arguments. This is the procedure that is called every time the task is invoked. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i msDelay} \cell }{\'96 the initial delay, in milliseconds \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b add}, {\b addWaitUntil}, {\b addAutoWaitDelay} \par
}}}}
{\xe \v addWaitMessage\:TaskManager}
{\xe \v TaskManager\:addWaitMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TaskManager::addWaitMessage (tm_taskId_t  {\i taskId}, void(*)()  {\i fn}, unsigned long  {\i timeout} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a task that is waiting for a message. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The task will be added, but will be waiting for a message. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i taskId} \cell }{- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fn} \cell }{\'96 this is a void function with no arguments. This is the procedure that is called every time the task is invoked. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i timeout} \cell }{\'96 the maximum time to wait (in ms) before timing out. \cell }
{\row }
}
}}
{\xe \v addWaitUntil\:TaskManager}
{\xe \v TaskManager\:addWaitUntil}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TaskManager::addWaitUntil (tm_taskId_t  {\i taskId}, void(*)()  {\i fn}, unsigned long  {\i msWhen})}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a task that will be delayed until a set system clock time before its first invocation. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This task will execute once each cycle. Its first execution will be delayed until a set system clock time. After this, unless the task forces itself into a different scheduling model (e.g., through yieldSignal), it will execute agaion at the next available opportunity. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i taskId} \cell }{- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fn} \cell }{\'96 this is a void function with no arguments. This is the procedure that is called every time the task is invoked. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i msWhen} \cell }{\'96 the initial delay, in milliseconds \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b add}, {\b addWaitDelay}, {\b addAutoWaitDelay} \par
}}}}
{\xe \v findTaskById\:TaskManager}
{\xe \v TaskManager\:findTaskById}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
_TaskManagerTask * TaskManager::findTaskById (tm_taskId_t  {\i id})}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Find a task by its ID. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i id} \cell }{the ID of the task \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A pointer to the _TaskManagerTask or NULL if not found \par
}}}}
{\xe \v getMessage\:TaskManager}
{\xe \v TaskManager\:getMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * TaskManager::getMessage (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a task's message buffer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A pointer to the actual message buffer. Use the contents of the buffer but do NOT modify it. If a task is killed, this pointer becomes invalid. \par
}}}}
{\xe \v getMessageLength\:TaskManager}
{\xe \v TaskManager\:getMessageLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t TaskManager::getMessageLength (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the length of the message in the buffer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The size of the data block in the buffer. Note that if the content is a string, the size will be one greater than the string length to account for the trailing null. \par
}}}}
{\xe \v getSource\:TaskManager}
{\xe \v TaskManager\:getSource}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TaskManager::getSource (tm_taskId_t &  {\i fromTaskId}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get task ID of last message/signal. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the taskId of the task that last sent a signal or message to the current task. If the current task has never received a signal, returns [0].\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i fromTaskId} \cell }{\'96 the taskId that sent the last message or signal \cell }
{\row }
}
}}
{\xe \v loop\:TaskManager}
{\xe \v TaskManager\:loop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TaskManager::loop ()}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements a single pass for the system {\b loop()} routine. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This performs a single iteration for the system {\b loop()} routine. It finds the next runnable task and runs it. It processes any yield*() operations that the user routine may have executed.\par
This routine is for internal use only. \par
}}
{\xe \v resume\:TaskManager}
{\xe \v TaskManager\:resume}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TaskManager::resume (tm_taskId_t  {\i taskId})}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resume the given task on this node. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resumes a task. If the task do not exist, nothing happens. If the task had not been suspended, nothing happens. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i taskId} \cell }{The task to be resumed\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Not implemented. \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b suspend()} \par
}}}}
{\xe \v sendMessage\:TaskManager}
{\xe \v TaskManager\:sendMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool TaskManager::sendMessage (tm_nodeId_t  {\i nodeId}, tm_taskId_t  {\i taskId}, char *  {\i message})}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sends a string message to a task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sends a message to a task. The message will go to only one task.\par
Note that once a task has been sent a message, it will not be waiting for other instances of the same siggnal number. Note that additional messages sent prior to the task executing will overwrite any prior messages. Messages that are too large are ignored. Remember to account for the trailing '\par
' when considering the string message size.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This routine is only available on ESP and RF24-enabled AVR environments.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i nodeId} \cell }{\'96 the node the message is sent to \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i taskId} \cell }{\'96 the ID number of the task \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i message} \cell }{\'96 the character string message. It is restricted in length to TASKMGR_MESSAGE_LENGTH-1 characters. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b yieldForMessage()} \par
}}}}
{\xe \v sendMessage\:TaskManager}
{\xe \v TaskManager\:sendMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TaskManager::sendMessage (tm_taskId_t  {\i taskId}, char *  {\i message}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sends a string message to a task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sends a message to a task. The message will go to only one task.\par
Note that once a task has been sent a message, it will not be waiting for other instances of the same siggnal number. Note that additional messages sent prior to the task executing will overwrite any prior messages. Messages that are too large are ignored. Remember to account for the trailing '\par
' when considering the string message size.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
In networked {\b TaskManager} environments, this will send the message to a task on the current node.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i taskId} \cell }{\'96 the ID number of the task \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i message} \cell }{\'96 the character string message. It is restricted in length to TASKMGR_MESSAGE_LENGTH-1 characters. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b yieldForMessage()} \par
}}}}
{\xe \v sendMessage\:TaskManager}
{\xe \v TaskManager\:sendMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TaskManager::sendMessage (tm_taskId_t  {\i taskId}, void *  {\i buf}, int  {\i len}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Send a binary message to a task. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sends a message to a task. The message will go to only one task. Note that once a task has been sent a message, it will not be waiting for other instances of the same signal number. Messages that are too large are ignored.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Additional messages sent prior to the task executing will overwrite any prior messages.\par
In networked {\b TaskManager} environments, this will send the message to a task on the current node.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i taskId} \cell }{\'96 the ID number of the task \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{\'96 A pointer to the structure that is to be passed to the task \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i len} \cell }{\'96 The length of the buffer. Buffers can be at most TASKMGR_MESSAGE_LENGTH bytes long. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b yieldForMessage()} \par
}}}}
{\xe \v suspend\:TaskManager}
{\xe \v TaskManager\:suspend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TaskManager::suspend (tm_taskId_t  {\i taskId})}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Suspend the given task on this node. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The given task will be suspended until it is resumed. It will not be allowed to run, nor will it receive messages or signals. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i taskId} \cell }{The task to be suspended \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Not implemented. \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
receive \par
}}}}
{\xe \v timedOut\:TaskManager}
{\xe \v TaskManager\:timedOut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool TaskManager::timedOut (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tell if the current task has timed out while waiting for a signal or message. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the task started due to timing out while waiting for a signal or message; false otherwise. \par
}}}}
{\xe \v yield\:TaskManager}
{\xe \v TaskManager\:yield}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TaskManager::yield ()}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exit from this task and return control to the task manager. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This exits from the current task, and returns control to the task manager. Functionally, it is similar to a return statement. The next time the task gains control, it will resume from the TOP of the routine. Note that if the task was an Auto task, it will be automatically rescheduled according to its Auto specifications. \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b yieldDelay()}, {\b yieldUntil()}, yieldSignal(), yieldMessage(), {\b addAutoWaitDelay()}, addAutoWaitSignal(), {\b addAutoWaitMessage()} \par
}}}}
{\xe \v yieldDelay\:TaskManager}
{\xe \v TaskManager\:yieldDelay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TaskManager::yieldDelay (unsigned long  {\i ms})}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exit from the task manager and do not restart this task until after a specified period. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This exits from the current task and returns control to the task manager. This task will not be rescheduled until at least the stated number of milliseconds has passed. Note that yieldDelay {\i overrides}  any of the Auto specifications. That is, the next rescheduling will occur {\i solely}  after the stated time period, and will not be constrained by AutoWaitSignal, AutoWaitMessage, or a different AutoWaitDelay value. The Auto specification will be retained, and will be applied on future executions where {\b yield()} or a normal return are used. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ms} \cell }{\'96 the delay in milliseconds. Note the next call may exceed this constraint depending on time taken by other tasks. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b yield()}, {\b yieldUntil()}, yieldSignal(), yieldMessage(), {\b addAutoWaitDelay()}, addAutoWaitSignal(), {\b addAutoWaitMessage()} \par
}}}}
{\xe \v yieldForMessage\:TaskManager}
{\xe \v TaskManager\:yieldForMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TaskManager::yieldForMessage (unsigned long  {\i timeout} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exit from the task manager and do not restart this task until a message has been received or a stated time period has passed. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This exits from the current task and returns control to the task manager. This task will not be rescheduled until a message has been received or a stated time period has passed (the timeout period). The TaskManager::timeOut() function will tell whether or not the timeout had been triggered.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The yieldForMessage call {\i overrides}  any of the Auto specifications. That is, the next rescheduling will occur {\i solely}  after the signal has been received, and will not be constrained by AutoWaitDelay, AutoWaitSignal, or a different AutoWaitMessage value. The Auto specification will be retained, and will be applied on future executions where {\b yield()} or a normal return are used. \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i timeout} \cell }{\'96 The timeout period, in milliseconds. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b yield()}, {\b yieldDelay()}, yieldForSignal(), {\b addAutoWaitDelay()}, addAutoWaitSignal(), {\b addAutoWaitMessage()}, timeOut() \par
}}}}
{\xe \v yieldUntil\:TaskManager}
{\xe \v TaskManager\:yieldUntil}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TaskManager::yieldUntil (unsigned long  {\i when})}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exit from the task manager and do not restart this task until (after) a specified CPU clock time. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This exits from the current task and returns control to the task manager. This task will not be rescheduled until the CPU clock (millis()) has exceeded the given time. Note that yieldUntil {\i overrides}  any of the Auto specifications. That is, the next rescheduling will occur {\i solely}  after the stated clock time has passed, and will not be constrained by AutoWaitSignal, AutoWaitMessage, or a different AutoWaitDelay value. The Auto specification will be retained, and will be applied on future executions where {\b yield()} or a normal return are used. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i when} \cell }{\'96 The target CPU time. Note the next call may exceed this constraint depending on time taken by other tasks. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b yield()}, {\b yieldDelay()}, yieldSignal(), yieldMessage(), {\b addAutoWaitDelay()}, addAutoWaitSignal(), {\b addAutoWaitMessage()} \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
TaskManagerCore_2.h\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
TaskManager_2.cpp\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TaskManager_2.h\par \pard\plain 
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 // Main program include for TaskManagerRF}\par
2 {\cf20 // Note this file should only be #include'd from the main program.}\par
3 {\cf20 // Other C++ files in the program should #include TaskManagerSub.h}\par
4 {\cf21 #ifndef TASKMANAGER_H_INCLUDED}\par
5 {\cf21 #define TASKMANAGER_H_INCLUDED}\par
6 \par
7 {\cf20 //#define TASKMANAGER_DEBUG}\par
8 {\cf21 #include <TaskManagerMacros_2.h>}\par
9 {\cf21 #include <TaskManagerCore_2.h>}\par
10 {\cf20 // These need to be here to ensure these are declared.}\par
11 {\cf20 // Note that each main-file include in the TaskManager family has one of these.}\par
12 {\cf20 // This ensures that the correct TaskMgr is used.}\par
13 TaskManager TaskMgr;\par
14 {\cf18 void} loop() \{\par
15     TaskMgr.loop();\par
16 \}\par
17 {\cf21 #endif }{\cf20 // TASKMANAGER_H_INCLUDED}\par
18 \par
19 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TaskManagerBoilerplates_2.h\par \pard\plain 
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 // NOT FOR RELEASE}\par
2 {\cf20 // EXPERIMENTAL/TEST CODE}\par
3 \par
4 {\cf20 // TaskManager Boilerplates}\par
5 {\cf20 //}\par
6 \par
7 {\cf20 // Various boilerplate utilities}\par
8 \par
9 {\cf20 // Unblocking Read}\par
10 {\cf20 // Read from a stream into a String}\par
11 {\cf20 // This is useful in TM_Macro code, so it will need TM_BEGIN() and TM_END().}\par
12 {\cf20 //  stream_in is the stream to use (normally Serial)}\par
13 {\cf20 //  string_out is the string variable to place the results in}\par
14 {\cf20 //  yield_id is the TM_MACRO ID for TM_YIELD}\par
15 {\cf20 //  echo is a boolean -- if true, echo the characters back to stream_in as read in}\par
16 {\cf20 // TM_READLINE(stream_in, string_out, yield_id, echo)}\par
17 {\cf21 #define TM_READLINE(stream_in, string_out, yield_id, echo)          \\}\par
18 {\cf21   \{ }{\cf20 /* read in a whole line of chars into cmd   */}{\cf21                   \\}\par
19 {\cf21     char ch;                                                        \\}\par
20 {\cf21     bool done;                                                      \\}\par
21 {\cf21     bool lastWasCr;                                                 \\}\par
22 {\cf21     cmd = ""};                                                       \\\par
23     done = false;                                                   \\\par
24     lastWasCr = false;                                              \\\par
25     while(!done) \{                                                  \\\par
26       while(!stream_in.available()) \{ TM_YIELD(yield_id); \}         \\\par
27       ch = stream_in.read();                                        \\\par
28       {\cf20 /* Backspace processing for PuTTY */}{\cf21                           \\}\par
29 {\cf21       if(ch==0x08 && echo) \{                                        \\}\par
30 {\cf21         if(cmd.length()>0) \{                                        \\}\par
31 {\cf21           Serial << '\\b' << ' ' << '\\b';                            \\}\par
32 {\cf21           cmd.remove(cmd.length()-1);                               \\}\par
33 {\cf21         \}                                                           \\}\par
34 {\cf21       \} else \{                                                      \\}\par
35 {\cf21         }{\cf20 /* CR processing for PuTTY */}{\cf21                                \\}\par
36 {\cf21         if(ch=='\\r') \{ ch='\\n'; lastWasCr = true; \}                 \\}\par
37 {\cf21         else if(ch=='\\n' && lastWasCr) \{ lastWasCr=false; continue; \} }{\cf20 /* crlf, skip the lf */}{\cf21        \\}\par
38 {\cf21         if(ch=='\\n') \{ Serial << ch; lastWasCr = false; done = true; \}                              \\}\par
39 {\cf21         else \{                                                      \\}\par
40 {\cf21           if(echo)Serial << ch;                                     \\}\par
41 {\cf21           string_out += ch;                                         \\}\par
42 {\cf21           lastWasCr = false;                                        \\}\par
43 {\cf21         \} }{\cf20 /* end if(ch=='\\n') else */}{\cf21                                \\}\par
44 {\cf21       \} }{\cf20 /* end if(ch==0x08) else */}{\cf21                                  \\}\par
45 {\cf21     \} }{\cf20 /* end while */}{\cf21                                                \\}\par
46 {\cf21   \} }{\cf20 /* end read in a whole line of chars */}{\cf21 }\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TaskManagerCore_2.h\par \pard\plain 
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef TASKMANAGERCORE_H_INCLUDED}\par
2 {\cf21 #define TASKMANAGERCORE_H_INCLUDED}\par
3 \par
4 {\cf20 /* AVR Networking (RF24) Note:}\par
5 {\cf20    Uncomment this #define ONLY IF you wish the ACR RF24 networking code to be included.}\par
6 {\cf20    This will incorporate RF24 components into AVR compilations.}\par
7 {\cf20    Any AVR program using this will also have to #include <RF24.h> prior #include <TaskManagerRF24.h>}\par
8 {\cf20 */}\par
9 {\cf20 //#define TASKMGR_AVR_RF24}\par
10 \par
11 {\cf20 //#include <Streaming.h>}\par
12 {\cf20 //#include <ring_2.h>}\par
13 \par
14 {\cf20 // Process includes for networking code}\par
15 {\cf21 #if defined(ARDUINO_ARCH_AVR) && defined(TASKMGR_AVR_RF24)}\par
16 {\cf21 #elif defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32)}\par
17 {\cf21 #include <esp_now.h>}\par
18 {\cf21 #include <WiFi.h>}\par
19 {\cf21 #include <esp_wifi.h>}\par
20 {\cf21 #endif}\par
21 \par
22 {\cf21 #include <setjmp.h>}\par
23 \par
28 {\cf20 /**********************************************/}\par
29 {\cf20 /*  Class ring -- an stl-like ring of objects */}\par
30 {\cf20 /*  Implementation at the end of this file    */}\par
35 {\cf20 //}\par
36 {\cf20 // The ring class implements a templated ring structure.  It implements many of}\par
37 {\cf20 // the methods of an STL collection.}\par
38 \par
39 {\cf17 template}<{\cf17 class} T> {\cf17 class }ring;   {\cf20 // forward declaration}\par
40 \par
41 {\cf20 // Definition of a single node in the ring.  This is the actual data.}\par
42 {\cf20 // It is a doubly-linked list that loops in both directions.  A pointer to}\par
43 {\cf20 // one of the elements defines the "current" element in the ring.}\par
48 {\cf20 }{\cf17 template}<{\cf17 class} T>{\cf17 class }_ringNode \{\par
49     {\cf17 friend} {\cf17 class }ring<T>;\par
50 {\cf17 protected}:\par
51     T m_val;\par
52     _ringNode* m_next;\par
53     _ringNode* m_prev;\par
54 \};\par
55 \par
56 {\cf20 // The ring object.  It contains a pointer to the "current" element of}\par
57 {\cf20 // a series of _ringNode objects/}\par
58 {\cf20 //}\par
59 {\cf20 // Note that front() and back() return a reference to the first data element.}\par
60 {\cf20 // This allows operations like myRing->front()++ to increment the value in}\par
61 {\cf20 // a ring of ints, for example.  front() and back() do not remove values.}\par
62 {\cf20 // If the ring is empty, front() and back() will blow up.  This is keeping}\par
63 {\cf20 // with STL standard:  these operations are not defined on empty collections.}\par
64 \par
74 {\cf17 template}<{\cf17 class} T>{\cf17 class }ring \{\par
75     {\cf17 private}:\par
76     _ringNode<T>* m_cur;\par
77     {\cf18 char}* m_prefix;\par
78 \par
79 {\cf17 public}:\par
80     {\cf20 //***** Constructor, destructor}\par
82 {\cf20 }    ring(): m_cur(NULL), m_prefix((char*){\cf22 "r: "}) \{\}\par
88     ~ring() \{\}\par
89 \par
90 \par
91     {\cf18 void} push_front(T val);\par
92 \par
93     {\cf18 void} push_back(T val);\par
94 \par
95     {\cf20 //***** removal}\par
96 \par
97     {\cf18 void} pop_front();\par
98     {\cf18 void} pop_back();\par
99     {\cf18 void} clear();\par
100 \par
101     {\cf20 // access}\par
102 \par
103     T& front() {\cf17 const};\par
104     T& back() {\cf17 const};\par
105 \par
106     {\cf20 // moving around}\par
107 \par
108     {\cf18 void} move_next();\par
109     {\cf18 void} move_prev();\par
110 \par
111     {\cf20 // query for info}\par
112     {\cf18 bool} empty() {\cf17 const};\par
113     {\cf18 size_t} size() {\cf17 const};\par
114 \par
115     {\cf20 // assignment and comparison (equality)}\par
116     ring<T>& operator=(ring<T>& r);\par
117     {\cf18 bool} operator==(ring<T>& r) {\cf17 const};\par
118 \par
119     {\cf20 // mapping operations}\par
120     {\cf18 void} map({\cf18 void} (*fn)(T& ));\par
121     {\cf18 void} map({\cf18 void} (*fn)(T& , {\cf18 void}* ), {\cf18 void}* );\par
122 \};\par
125 {\cf20 /*  End of class ring */}\par
126 {\cf20 /**********************/}\par
127 \par
141 {\cf21 #if defined(ARDUINO_ARCH_AVR)}\par
142 {\cf17 typedef} uint8_t tm_nodeId_t;\par
143 {\cf17 typedef} uint8_t tm_taskId_t;\par
144 {\cf21 #define TASKMGR_MESSAGE_SIZE (32-1-sizeof(tm_nodeId_t)-2*sizeof(tm_taskId_t))}\par
145 {\cf21 #elif defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32)}\par
146 {\cf17 typedef} uint16_t tm_nodeId_t;\par
147 {\cf17 typedef} uint8_t tm_taskId_t;\par
148 {\cf21 #define TASKMGR_MESSAGE_SIZE (250-1-sizeof(tm_nodeId_t)-2*sizeof(tm_taskId_t))}\par
149 {\cf21 #else}\par
150 {\cf21 #endif}\par
151 \par
155 {\cf20 /**********************************************/}\par
156 {\cf20 /* class _TaskManagerRadioPacket -- the info  */}\par
157 {\cf20 /* transmitted between nodes to pass messages */}\par
158 {\cf21 #if (defined(ARDUINO_ARCH_AVR) && defined(TASKMGR_AVR_RF24)) || defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32)}\par
165 {\cf17 struct }_TaskManagerRadioPacket \{\par
166     {\cf18 byte}    m_cmd;                          \par
167     tm_nodeId_t m_fromNodeId;                       {\cf20 // source node}\par
168     tm_taskId_t m_fromTaskId;                       {\cf20 // source task}\par
169     {\cf18 byte}    m_data[TASKMGR_MESSAGE_SIZE];   \par
170 \} __attribute__((packed));\par
171 {\cf21 #if defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32)}\par
172 {\cf20 // This is where we build MAC data for setting our MAC and pairing setup}\par
173 {\cf20 // It has enough constant data that it is easier to just keep one around.}\par
174 {\cf17 static} {\cf18 byte} _TaskManagerMAC[] = \{ 0xA6, {\cf23 'T'}, {\cf23 'M'},  0, 0x00, 0x00 \};\par
175 {\cf21 #endif}\par
176 {\cf21 #endif}\par
177 \par
178 {\cf20 /*  FIXED TASKS */}\par
182 {\cf21 #if defined(ARDUINO_ARCH_AVR)}\par
183 {\cf21 #define TASKMGR_NULL_TASK 255}\par
184 {\cf21 #elif defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32)}\par
185 {\cf21 #define TASKMGR_NULL_TASK 255}\par
186 {\cf21 #endif}\par
190 {\cf21 #define TASKMGR_RF_MONITOR_TASK (TASKMGR_NULL_TASK-1)}\par
191 \par
195 {\cf21 #define TASKMGR_PING_MONITOR_TASK (TASKMGR_NULL_TASK-2)}\par
196 \par
200 {\cf21 #define TASKMGR_MENU_MONITOR_TASK (TASKMGR_NULL_TASK-3)}\par
201 \par
215 {\cf17 class }TaskManager;  {\cf20 // forward declaration}\par
216 \par
217 {\cf21 #if defined(TASKMANAGER_DEBUG)}\par
218 {\cf17 class }_TaskManagerTask: {\cf17 public} Printable \{\par
219 {\cf21 #else}\par
220 {\cf17 class }_TaskManagerTask \{\par
221 {\cf21 #endif}\par
222     {\cf17 friend} {\cf17 class }TaskManager;\par
223 {\cf17 protected}:\par
226     {\cf20 /* \\@ */}\par
230     {\cf17 enum} TaskStates \{UNUSED01=0x01,     {\cf20 // RFU}\par
231         WaitMessage=0x02,               \par
232         WaitUntil=0x04,                 \par
233         UNUSED08 = 0x08,                {\cf20 // RFU}\par
234         AutoReWaitMessage = 0x10,       \par
235         AutoReWaitUntil = 0x20,         \par
236         TimedOut = 0x40,                \par
237         Suspended=0x80                  \par
238         \};\par
239     {\cf20 /* \\\} */}\par
240 {\cf17 public}:\par
241     tm_nodeId_t m_fromNodeId;       {\cf20 // where the signal/message came from}\par
242     tm_taskId_t m_fromTaskId;\par
243 {\cf17 protected}:\par
244     uint8_t m_stateFlags; \par
245 \par
246     {\cf20 // Active delay information.  If a task is waiting, here is the reason (or in the}\par
247     {\cf20 // case of messaging, the response)}\par
248     {\cf18 unsigned} {\cf18 long} m_restartTime;  \par
250 \par
251 \par
252     {\cf18 char} m_message[TASKMGR_MESSAGE_SIZE];   \par
253     uint16_t m_messageLength;\par
254 \par
255     {\cf20 //NOT USED??? unsigned int m_reTimeout;   //!< The timeout to use during auto restarts.  0 means no timeout.}\par
256 \par
257     {\cf20 // Autorestart information.  If a task has autorestart, here is the information to use at the restart}\par
258     {\cf18 unsigned} {\cf18 long} m_period; \par
259 \par
260     tm_taskId_t    m_id; \par
261     void    (*m_fn)(); \par
262 \par
263 {\cf17 public}:\par
267     {\cf20 // Constructors and destructors}\par
268     _TaskManagerTask();\par
269     _TaskManagerTask(tm_taskId_t {\cf18 id}, {\cf18 void} (*fn)());\par
270     ~_TaskManagerTask();\par
272 {\cf17 protected}:\par
273     {\cf20 // State bit manipulation methods}\par
274     {\cf18 bool} anyStateSet({\cf18 byte});\par
275     {\cf18 bool} allStateSet({\cf18 byte});\par
276     {\cf18 bool} stateTestBit({\cf18 byte});\par
277     {\cf18 void} stateSet({\cf18 byte});\par
278     {\cf18 void} stateClear({\cf18 byte} bits);\par
279     {\cf18 void} resetCurrentStateBits();\par
280 \par
281     {\cf20 // Querying its state and other info}\par
282     {\cf18 bool} isRunnable();\par
283 \par
284     {\cf20 // Setting its state}\par
285     {\cf18 void} setRunnable();\par
286     {\cf18 void} setSuspended();\par
287     {\cf18 void} clearSuspended();\par
288     {\cf18 void} setWaitUntil({\cf18 unsigned} {\cf18 long});\par
289     {\cf18 void} setWaitDelay({\cf18 unsigned} {\cf18 int});\par
290     {\cf18 void} setAutoDelay({\cf18 unsigned} {\cf18 int});\par
291     {\cf18 void} setWaitMessage({\cf18 unsigned} {\cf18 int} msTimeout=0);\par
292     {\cf18 void} setAutoMessage({\cf18 unsigned} {\cf18 int} msTimeout=0);\par
293 \par
294     {\cf20 // How to receive a signal/message}\par
295     {\cf18 void} signal();\par
296     {\cf18 void} putMessage({\cf18 void}* buf, {\cf18 int} len);\par
297 \par
298 {\cf17 public}:\par
299     {\cf20 // Things that make the ring of _TaskManagerTask work}\par
300     _TaskManagerTask& operator=(_TaskManagerTask& rhs);\par
301     {\cf18 bool} operator==(_TaskManagerTask& rhs) {\cf17 const};\par
302 \par
303     {\cf20 // Miscellaneous methods}\par
304 {\cf21 #if defined(TASKMANAGER_DEBUG)}\par
305     {\cf18 size_t} printTo(Print& p) {\cf17 const};\par
306 {\cf21 #endif}\par
307 \};\par
311 {\cf20 /**********************************************************************************************************/}\par
312 \par
325 {\cf21 #if defined(TASKMANAGER_PRINTABLE)}\par
326 {\cf17 class }TaskManager: {\cf17 public} Printable \{\par
327 {\cf21 #else}\par
328 {\cf17 class }TaskManager \{\par
329 {\cf21 #endif}\par
330 {\cf21 #if defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32)}\par
331 {\cf17 private}:\par
332     RF24*   m_rf24;             {\cf20 // Our radio (dynamically allocated)    }\par
333 {\cf21 #endif}\par
334 {\cf17 public}:\par
335     ring<_TaskManagerTask> m_theTasks; \par
336 \par
337 {\cf17 private}:\par
338     {\cf18 unsigned} {\cf18 long} m_startTime;  {\cf20 // Start clock time.  Used to calcualte runtime. For internal use only.}\par
339 {\cf17 public}:\par
340     {\cf20 // Constructor and destructor}\par
341     {\cf20 // Not included in doxygen documentation because the}\par
342     {\cf20 // user never constructs or destructs a TaskManager object}\par
345 {\cf20 }    TaskManager();\par
346     \par
352     ~TaskManager();\par
353 \par
354 \par
355     {\cf20 // Things used by yield}\par
356 {\cf17 private}:\par
357     {\cf20 /* Defines the different methods a process may yield control.}\par
358 {\cf20 }\par
359 {\cf20         This is the return value passsed back by the different yield*() routines to the control `loop()`.}\par
360 {\cf20         It indicates which form of yield*() was called.}\par
361 {\cf20 }\par
362 {\cf20         This is for internal use only.}\par
363 {\cf20     */}\par
364     {\cf17 enum} YieldTypes \{ YtYield,\par
365         YtYieldUntil,\par
366         YtYieldMessage,\par
367         YtYieldMessageTimeout,\par
368         YtYieldSuspend,\par
369         YtYieldKill\par
370         \};\par
371     jmp_buf  taskJmpBuf;    {\cf20 // Jump buffer used by yield.  For internal use only.}\par
372 \par
373 {\cf17 public}:\par
390     {\cf18 void} add(tm_taskId_t taskId, {\cf18 void} (*fn)());\par
391 \par
404     {\cf18 void} addWaitDelay(tm_taskId_t taskId, {\cf18 void}(*fn)(), {\cf18 unsigned} {\cf18 long} msDelay);\par
405 \par
418     {\cf18 void} addWaitUntil(tm_taskId_t taskId, {\cf18 void}(*fn)(), {\cf18 unsigned} {\cf18 long} msWhen);\par
419 \par
429     {\cf18 void} addWaitMessage(tm_taskId_t taskId, {\cf18 void}(*fn)(), {\cf18 unsigned} {\cf18 long} timeout=0);\par
430 \par
448     {\cf18 void} addAutoWaitDelay(tm_taskId_t taskId, {\cf18 void}(*fn)(), {\cf18 unsigned} {\cf18 long} period, {\cf18 bool} startDelayed={\cf17 false});\par
449 \par
464     {\cf18 void} addAutoWaitMessage(tm_taskId_t taskId, {\cf18 void}(*fn)(), {\cf18 unsigned} {\cf18 long} timeout=0, {\cf18 bool} startWaiting={\cf17 true}); \par
484     {\cf18 void} yield();\par
485 \par
496     {\cf18 void} yieldDelay({\cf18 unsigned} {\cf18 long} ms);\par
497 \par
508     {\cf18 void} yieldUntil({\cf18 unsigned} {\cf18 long} when);\par
509 \par
523     {\cf18 void} yieldForMessage({\cf18 unsigned} {\cf18 long} timeout=0);\par
553     {\cf18 void} sendMessage(tm_taskId_t taskId, {\cf18 char}* message);       {\cf20 // string}\par
554 \par
574     {\cf18 void} sendMessage(tm_taskId_t taskId, {\cf18 void}* buf, {\cf18 int} len);\par
575     \par
594     {\cf18 bool} sendMessage(tm_nodeId_t nodeId, tm_taskId_t taskId, {\cf18 char}* message);\par
595 \par
596 {\cf21 #if (defined(ARDUINO_ARCH_AVR) && defined(TASKMGR_AVR_RF24)) || defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32)}\par
614     {\cf18 bool} sendMessage(tm_nodeId_t nodeId, tm_taskId_t taskId, {\cf18 void}* buf, {\cf18 int} len);\par
615 {\cf21 #endif}\par
616 \par
624     {\cf18 void} getSource(tm_taskId_t& fromTaskId);\par
625 {\cf21 #if (defined(ARDUINO_ARCH_AVR) && defined(TASKMGR_AVR_RF24)) || defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32)}\par
637     {\cf18 void} getSource(tm_nodeId_t& fromNodeId, tm_taskId_t& fromTaskId);\par
638 {\cf21 #endif}\par
639 \par
669     {\cf18 void} suspend(tm_taskId_t taskId);                   {\cf20 // task}\par
670     \par
671 {\cf21 #if (defined(ARDUINO_ARCH_AVR) && defined(TASKMGR_AVR_RF24)) || defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32)}\par
684     {\cf18 bool} suspend(tm_nodeId_t nodeId, tm_taskId_t taskId);           {\cf20 // node, task}\par
685 {\cf21 #endif  }\par
686 \par
696     {\cf18 void} resume(tm_taskId_t taskId);                    {\cf20 // task}\par
697     \par
698 {\cf21 #if (defined(ARDUINO_ARCH_AVR) && defined(TASKMGR_AVR_RF24)) || defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32)}\par
709     {\cf18 bool} resume(tm_nodeId_t nodeId, tm_taskId_t taskId);            {\cf20 // node, task}\par
710 {\cf21 #endif}\par
711 \par
714     {\cf20 /* **** Mesh/Radio Internal Routines */}\par
715 {\cf21 #if (defined(ARDUINO_ARCH_AVR) && defined(TASKMGR_AVR_RF24)) || defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32)}\par
716 {\cf17 private}:\par
717     {\cf18 bool} radioSender(tm_nodeId_t);  {\cf20 // generic packet sender}\par
718 \par
719     {\cf20 // status requests/}\par
720     {\cf20 //void yieldPingNode(byte);                 // node -> status (responding/not responding)}\par
721     {\cf20 //void yieldPingTask(byte, byte);               // node, task -> status}\par
722     {\cf20 //bool radioFree();                     // Is the radio available for use?}\par
723 \par
724     {\cf20 // radio}\par
725 {\cf17 private}:\par
726     {\cf20 // notes on parameters to the commands}\par
727     {\cf20 //  signal, signalAll: m_data[0] = sigNum}\par
728     {\cf20 //  message: m_data[0] = taskID, m_data[1+] = message}\par
729     {\cf20 //  suspend, resume: m_data[0] = taskID}\par
730     {\cf17 enum} RadioCmd \{\par
731         tmrNoop,            \par
732         tmrStatus,          \par
733         tmrAck,             \par
734         tmrTaskStatus,      \par
735         tmrTaskAck,         \par
736         tmrMessage,         \par
737         tmrSuspend,         \par
738         tmrResume           \par
739     \};\par
740     _TaskManagerRadioPacket radioBuf;\par
741     {\cf18 bool}    m_radioReceiverRunning;\par
742 {\cf17 public}:\par
743     {\cf18 void} tmRadioReceiverTask();\par
744 \par
745 {\cf21 #if defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32)}\par
746 {\cf17 private}:\par
747     esp_err_t m_lastESPError;\par
748 {\cf21 #endif}\par
749 {\cf21 #endif}\par
750 \par
764 {\cf21 #if (defined(ARDUINO_ARCH_AVR) && defined(TASKMGR_AVR_RF24))}\par
765 {\cf17 public}:\par
777     {\cf18 void} radioBegin(tm_nodeId_t nodeId, {\cf18 byte} cePin, {\cf18 byte} csPin);\par
778 {\cf21 #elif defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32)}\par
779 {\cf17 public}:\par
802     {\cf18 bool} radioBegin(tm_nodeId_t nodeId, {\cf17 const} {\cf18 char}* ssid=NULL, {\cf17 const} {\cf18 char}* pw=NULL);\par
803 \par
804     {\cf20 /* \\brief Add a peer for ESP-Now communications}\par
805 {\cf20 }\par
806 {\cf20         \\param nodeID -- A peer node for future communications.}\par
807 {\cf20         \\note This routine is only available on ESP environments.}\par
808 {\cf20     */}\par
809     {\cf18 bool} registerPeer(tm_nodeId_t nodeId);\par
810 \par
811     {\cf20 /*  \\brief Remove a peer from ESP-Now communications}\par
812 {\cf20         \\param nodeID -- A peer node that will no longer be usable as a peer}\par
813 {\cf20         \\note This routine is only available on ESP environments.}\par
814 {\cf20     */}\par
815     {\cf18 bool} unRegisterPeer(tm_nodeId_t nodeId);\par
816 {\cf21 #endif}\par
817 \par
818 {\cf21 #if (defined(ARDUINO_ARCH_AVR) && defined(TASKMGR_AVR_RF24)) || defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32)}\par
824     tm_nodeId_t myNodeId();\par
825 {\cf21 #endif}\par
833     {\cf18 unsigned} {\cf18 long} runtime() {\cf17 const};\par
834 {\cf21 #if defined(TASKMANAGER_DEBUG)}\par
835     {\cf18 size_t} printTo(Print& p) {\cf17 const};\par
836 {\cf21 #endif}\par
840     {\cf18 bool} timedOut();\par
841 \par
846     {\cf18 void}* getMessage();\par
847 \par
852     uint16_t getMessageLength();\par
853 \par
857     tm_taskId_t myId();\par
858 \par
861     {\cf20 // We need a publicly available TaskManager::loop() so our global loop() can use it}\par
862     {\cf18 void} loop();\par
863 \par
864 {\cf17 protected}:\par
865     {\cf18 void} internalSendMessage(tm_nodeId_t fromNodeId, tm_taskId_t fromTaskId, tm_taskId_t taskId, {\cf18 char}* message);\par
866     {\cf18 void} internalSendMessage(tm_nodeId_t fromNodeId, tm_taskId_t fromTaskId, tm_taskId_t taskId, {\cf18 void}* buf, {\cf18 int} len);\par
867 \par
868 {\cf17 private}:\par
869     {\cf20 // Find the next active task}\par
870     {\cf20 // Note: there will always be a runnable task (tne null task) on the list.}\par
871     _TaskManagerTask* FindNextRunnable();\par
872 \par
873     {\cf20 // internal utility}\par
874 {\cf17 public}:\par
875     _TaskManagerTask* findTaskById(tm_taskId_t {\cf18 id});\par
876 \par
877 \};\par
881 {\cf20 //}\par
882 {\cf20 // Inline stuff}\par
883 {\cf20 //}\par
884 \par
888 {\cf20 // _TaskManagerTask Things}\par
889 \par
890 {\cf20 // Constructor and destructor}\par
896 {\cf20 }{\cf17 inline} _TaskManagerTask::_TaskManagerTask(): m_id(0), m_fn(NULL), m_stateFlags(0)\par
897 \{\par
898 \}\par
899 \par
904 {\cf17 inline} _TaskManagerTask::_TaskManagerTask(tm_taskId_t taskId, {\cf18 void} (*fn)()): m_id(taskId), m_fn(fn), m_stateFlags(0) \{\par
905 \}\par
908 {\cf17 inline} _TaskManagerTask::~_TaskManagerTask() \{\par
909 \}\par
910 \par
911 {\cf20 // Setting the task's state}\par
914 {\cf20 }{\cf17 inline} {\cf18 void} _TaskManagerTask::setRunnable() \{\par
915     stateClear(WaitMessage+WaitUntil+Suspended);\par
916 \}\par
919 {\cf17 inline} {\cf18 void} _TaskManagerTask::setSuspended() \{\par
920     stateSet(Suspended);\par
921 \}\par
925 {\cf17 inline} {\cf18 void} _TaskManagerTask::clearSuspended() \{\par
926     stateClear(Suspended);\par
927 \}\par
935 {\cf17 inline} {\cf18 void} _TaskManagerTask::setWaitUntil({\cf18 unsigned} {\cf18 long} when) \{\par
936     m_restartTime=when;\par
937     stateSet(WaitUntil);\par
938 \}\par
945 {\cf17 inline} {\cf18 void} _TaskManagerTask::setWaitDelay({\cf18 unsigned} {\cf18 int} ms)  \{\par
946     setWaitUntil(millis()+ms);\par
947 \}\par
962 {\cf17 inline} {\cf18 void} _TaskManagerTask::setAutoDelay({\cf18 unsigned} {\cf18 int} ms) \{\par
963     {\cf19 if}(ms>0) \{\par
964         m_period = ms;\par
965         stateSet(AutoReWaitUntil);\par
966     \}\par
967 \}\par
968 \par
976 {\cf17 inline} {\cf18 void} _TaskManagerTask::setWaitMessage({\cf18 unsigned} {\cf18 int} msTimeout{\cf20 /*=0*/})  \{\par
977     stateSet(WaitMessage);\par
978     {\cf19 if}(msTimeout>0) setWaitDelay(msTimeout);\par
979 \}\par
996 {\cf17 inline} {\cf18 void} _TaskManagerTask::setAutoMessage({\cf18 unsigned} {\cf18 int} msTimeout{\cf20 /*=0*/})  \{\par
997     stateSet(AutoReWaitMessage);\par
998     setAutoDelay(msTimeout);\par
999 \}\par
1000 \par
1001 {\cf20 //}\par
1002 {\cf20 // Sending messages to a task}\par
1003 {\cf20 //}\par
1004 \par
1012 {\cf17 inline} {\cf18 void} _TaskManagerTask::putMessage({\cf18 void}* buf, {\cf18 int} len) \{\par
1013     {\cf19 if}(len<=TASKMGR_MESSAGE_SIZE) \{\par
1014         memcpy(m_message, buf, len);\par
1015         m_messageLength = len;\par
1016         stateClear(WaitMessage+WaitUntil+TimedOut);\par
1017     \}\par
1018 \}\par
1019 \par
1020 {\cf20 //}\par
1021 {\cf20 // Testing the status bits of the task}\par
1022 {\cf20 //}\par
1027 {\cf20 }{\cf17 inline} {\cf18 bool} _TaskManagerTask::anyStateSet({\cf18 byte} bits) \{\par
1028     {\cf19 return} (m_stateFlags&bits) != 0;\par
1029 \}\par
1034 {\cf17 inline} {\cf18 bool} _TaskManagerTask::allStateSet({\cf18 byte} bits) \{\par
1035     {\cf19 return} (m_stateFlags&bits) == bits;\par
1036 \}\par
1041 {\cf17 inline} {\cf18 bool} _TaskManagerTask::stateTestBit({\cf18 byte} bit) \{\par
1042     {\cf19 return} anyStateSet(bit);\par
1043 \}\par
1047 {\cf17 inline} {\cf18 void} _TaskManagerTask::stateSet({\cf18 byte} bits) \{\par
1048     m_stateFlags |= bits;\par
1049 \}\par
1053 {\cf17 inline} {\cf18 void} _TaskManagerTask::stateClear({\cf18 byte} bits) \{\par
1054     m_stateFlags &= (~bits);\par
1055 \}\par
1058 {\cf17 inline} {\cf18 void} _TaskManagerTask::resetCurrentStateBits() \{\par
1059     m_stateFlags = (m_stateFlags&0xf8) + ((m_stateFlags>>3)&0x07);\par
1060 \}\par
1063 {\cf20  /*************** TaskManager Implementation ****************/}\par
1067 {\cf20 /*  \\brief Copy the auto state bits to the current state bits}\par
1068 {\cf20 */}\par
1069 \par
1070 \par
1071 {\cf17 inline} tm_taskId_t TaskManager::myId() \{\par
1072     {\cf19 return} m_theTasks.front().m_id;\par
1073 \};\par
1074 \par
1075 {\cf17 inline} {\cf18 bool} TaskManager::timedOut() \{\par
1076     {\cf19 return} m_theTasks.front().stateTestBit(_TaskManagerTask::TimedOut);\par
1077 \}\par
1078 \par
1079 {\cf17 inline} {\cf18 void} TaskManager::sendMessage(tm_taskId_t taskId, {\cf18 char}* message) \{\par
1080     internalSendMessage(0, myId(), taskId, message);\par
1081 \}\par
1082 \par
1083 {\cf17 inline} {\cf18 void} TaskManager::sendMessage(tm_taskId_t taskId, {\cf18 void}* buf, {\cf18 int} len) \{\par
1084     internalSendMessage(0, myId(), taskId, buf, len);\par
1085 \}\par
1086 \par
1087 {\cf17 inline} {\cf18 void}* TaskManager::getMessage() \{\par
1088     {\cf19 return} ({\cf18 void}*)(&(m_theTasks.front().m_message));\par
1089 \}\par
1090 \par
1091 {\cf17 inline} uint16_t TaskManager::getMessageLength() \{\par
1092     {\cf19 return} m_theTasks.front().m_messageLength;\par
1093 \}\par
1094 \par
1095 {\cf17 inline} {\cf18 void} TaskManager::getSource(tm_taskId_t& fromTaskId) \{\par
1096     fromTaskId = m_theTasks.front().m_fromTaskId;\par
1097 \}\par
1098 \par
1099 {\cf17 inline} {\cf18 unsigned} {\cf18 long} TaskManager::runtime(){\cf17  const }\{ {\cf19 return} millis()-m_startTime; \}\par
1104 {\cf20 /**************** ring implemenation ********************/}\par
1115 {\cf17 template}<{\cf17 class} T>{\cf18 void} ring<T>::push_front(T val) \{\par
1116     _ringNode<T>* newNode;\par
1117     newNode = {\cf17 new} _ringNode<T>();\par
1118     newNode->m_val = val;\par
1119     {\cf19 if}(m_cur==NULL) \{\par
1120         newNode->m_next = newNode;\par
1121         newNode->m_prev = newNode;\par
1122     \} {\cf19 else} \{\par
1123         newNode->m_next = m_cur;\par
1124         newNode->m_prev = m_cur->m_prev;\par
1125         m_cur->m_prev->m_next = newNode;\par
1126         m_cur->m_prev = newNode;\par
1127     \}\par
1128     m_cur = newNode;\par
1129 \}\par
1130 \par
1139 {\cf17 template}<{\cf17 class} T> {\cf17 inline} {\cf18 void} ring<T>::push_back(T val) \{\par
1140     this->push_front(val);\par
1141     this->move_next();\par
1142 \}\par
1143 \par
1151 {\cf17 template}<{\cf17 class} T> {\cf18 void} ring<T>::pop_front() \{\par
1152     _ringNode<T>* toGo; {\cf20 // node being deleted}\par
1153     {\cf19 if}(m_cur==NULL) {\cf19 return};\par
1154     toGo = m_cur;\par
1155     {\cf19 if}(m_cur=m_cur->m_next) \{ m_cur=NULL; \}\par
1156     {\cf19 else} \{\par
1157         m_cur->m_prev->m_next = m_cur->m_next;\par
1158         m_cur->m_next->m_prev = m_cur->m_prev;\par
1159     \}\par
1160     m_cur = m_cur->m_next;\par
1161     {\cf17 delete} toGo;\par
1162 \}\par
1163 \par
1171 {\cf17 template}<{\cf17 class} T>{\cf17 inline} {\cf18 void} ring<T>::pop_back() \{\par
1172     move_prev();\par
1173     pop_front();\par
1174 \}\par
1175 \par
1183 {\cf17 template}<{\cf17 class} T>{\cf18 void} ring<T>::clear() \{\par
1184     {\cf20 // temmpting to do this, but it wastes time copying pointers...}\par
1185     {\cf20 //  while(!empty() pop_front();}\par
1186     _ringNode<T>* cur;\par
1187     _ringNode<T>* last;\par
1188     _ringNode<T>* toGo;\par
1189     {\cf19 if}(empty()) {\cf19 return};\par
1190     {\cf19 for}(cur=m_cur, last=m_cur->m_prev; cur!=last; ) \{\par
1191         toGo = cur;\par
1192         cur = cur->m_next;\par
1193         {\cf17 delete} toGo;\par
1194     \}\par
1195     {\cf17 delete} cur;\par
1196     m_cur = NULL;\par
1197 \}\par
1198 \par
1205 {\cf17 template}<{\cf17 class} T> {\cf17 inline} T& ring<T>::front(){\cf17  const }\{\par
1206     {\cf19 return} (m_cur->m_val);\par
1207 \}\par
1208 \par
1215 {\cf17 template}<{\cf17 class} T> {\cf17 inline} T& ring<T>::back(){\cf17  const }\{\par
1216     {\cf19 return} (m_cur->m_prev->m_val);\par
1217 \}\par
1218 \par
1225 {\cf17 template}<{\cf17 class} T>{\cf17 inline} {\cf18 void} ring<T>::move_next() \{\par
1226     {\cf19 if}(m_cur!=NULL) m_cur = m_cur->m_next;\par
1227 \}\par
1228 \par
1235 {\cf17 template}<{\cf17 class} T>{\cf17 inline} {\cf18 void} ring<T>::move_prev() \{\par
1236     {\cf19 if}(m_cur!=NULL) m_cur=m_cur->m_prev;\par
1237 \}\par
1238 \par
1243 {\cf17 template}<{\cf17 class} T> {\cf17 inline} {\cf18 bool} ring<T>::empty(){\cf17  const}\{\par
1244     {\cf19 return} m_cur==NULL;\par
1245 \}\par
1246 \par
1251 {\cf17 template}<{\cf17 class} T> {\cf18 size_t} ring<T>::size(){\cf17  const }\{\par
1252     _ringNode<T>* cur;\par
1253     _ringNode<T>* last;\par
1254     {\cf18 size_t} ret;\par
1255     {\cf19 if}(m_cur==NULL) {\cf19 return} 0;\par
1256     {\cf19 for}(cur=m_cur, last=m_cur->m_prev, ret=1; cur!=last; cur=cur->m_next)\par
1257         ret++;\par
1258     {\cf19 return} ret;\par
1259 \}\par
1260 \par
1268 {\cf17 template}<{\cf17 class} T> {\cf17 inline} ring<T>& ring<T>::operator=(ring<T>& r) \{\par
1269     m_cur = r.m_cur;\par
1270 \}\par
1271 \par
1281 {\cf17 template}<{\cf17 class} T> {\cf17 inline} {\cf18 bool} ring<T>::operator==(ring<T>& r){\cf17  const }\{\par
1282     {\cf19 return} m_cur==r.m_cur;\par
1283 \}\par
1284 \par
1285 {\cf20 // Mapping functions}\par
1286 \par
1294 {\cf17 template}<{\cf17 class} T>{\cf18 void} ring<T>::map({\cf18 void} (*fn)(T&)) \{\par
1295     _ringNode<T>* cur;\par
1296     _ringNode<T>* last;\par
1297     {\cf19 if}(empty()) {\cf19 return};\par
1298     {\cf19 for}(cur=m_cur, last=m_cur->m_prev; cur!=last; cur=cur->m_next) \{\par
1299         (fn)(cur->m_val);\par
1300     \}\par
1301     (fn)(cur->m_val);\par
1302 \}\par
1303 \par
1315 {\cf17 template}<{\cf17 class} T>{\cf18 void} ring<T>::map({\cf18 void} (*fn)(T&, {\cf18 void}*), {\cf18 void}* p) \{\par
1316     _ringNode<T>* cur;\par
1317     _ringNode<T>* last;\par
1318     {\cf19 if}(empty()) {\cf19 return};\par
1319     {\cf19 for}(cur=m_cur, last=m_cur->m_prev; cur!=last; cur=cur->m_next) \{\par
1320         (fn)(cur->m_val, p);\par
1321     \}\par
1322     (fn)(cur->m_val, p);\par
1323 \}\par
1327 {\cf20 /*************** end of ring implementation *************/}\par
1328 \par
1329 {\cf20 /**************** ESP32 Network ************************/}\par
1333 {\cf21 #if (defined(ARDUINO_ARCH_AVR) && defined(TASKMGR_AVR_RF24)) || defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32)}\par
1334 {\cf17 inline} tm_nodeId_t TaskManagerESP::myNodeId() \{\par
1335     {\cf19 return} m_myNodeId;\par
1336 \}\par
1337 {\cf21 #endif}\par
1338 \par
1339 {\cf20 /* This defines the ESP32 networking routines.  They are only available on ESP32 compilations */}\par
1340 {\cf21 #if defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32)}\par
1341 {\cf21 #endif}\par
1342 \par
1343 {\cf20 /**************** End of ESP32 Network *******************/}\par
1344 \par
1345 {\cf20 /**************** AVR Network *************************/}\par
1346 {\cf21 #if defined(ARDUINO_ARCH_AVR) && defined(TASKMGR_AVR_RF24)}\par
1347 {\cf21 #endif}\par
1348 {\cf20 /**************** ENd of AVR Network ********************/}\par
1351 {\cf21 #endif }{\cf20 // TASKMANAGER_H_INCLUDED}\par
1352 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TaskManagerMacros_2.h\par \pard\plain 
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //}\par
2 {\cf20 // TaskManager Macros}\par
3 {\cf20 //}\par
4 {\cf20 // Used to implement in-process calls to TaskManager routines}\par
5 {\cf20 // such as Yield, and continuing on the next statement}\par
6 {\cf20 //}\par
7 {\cf20 // Based on a complete abuse of the switch()\{\} statement, akin to the Duff Device}\par
8 {\cf20 //}\par
9 \par
14 {\cf21 #if !defined(TASKMANAGERMACROS_DEFINED)}\par
15 {\cf21 #define TASKMANAGERMACROS_DEFINED}\par
16 \par
23 {\cf20 /* @\{ */}\par
24 \par
31 {\cf21 #define TM_BEGIN()                          \\}\par
32 {\cf21     static unsigned int __tmNext__ = 0;         \\}\par
33 {\cf21     switch(__tmNext__) \{                    \\}\par
34 {\cf21         case 0:}\par
35 {\cf20 // for compatibility with older code}\par
36 {\cf20 //#define TM_INIT() TM_BEGIN()}\par
37 \par
44 {\cf21 #define TM_END()                        \\}\par
45 {\cf21         default:    break;                  \\}\par
46 {\cf21     \}                                       \\}\par
47 {\cf21     __tmNext__ = 0;}\par
48 \par
52 {\cf21 #define TM_RETURN() \{ __tmNext__ = 0; return; \}}\par
53 \par
54 \par
62 {\cf21 #define TM_YIELD(n) \{                       \\}\par
63 {\cf21             __tmNext__ = n;                 \\}\par
64 {\cf21             TaskMgr.yield();                \\}\par
65 {\cf21         case n:  ;   \}}\par
66 \par
75 {\cf21 #define TM_YIELDDELAY(n,ms) \{               \\}\par
76 {\cf21             __tmNext__ = n;                 \\}\par
77 {\cf21             TaskMgr.yieldDelay(ms);         \\}\par
78 {\cf21         case n: ; \}}\par
79 \par
87 {\cf21 #define TM_YIELDMESSAGE(n)  \{               \\}\par
88 {\cf21             __tmNext__ = n;                 \\}\par
89 {\cf21             TaskMgr.yieldForMessage();      \\}\par
90 {\cf21         case n: ; \}}\par
91 \par
100 {\cf21 #define TM_YIELDMESSAGETIMEOUT(n,msto)  \{   \\}\par
101 {\cf21             __tmNext__ = n;                 \\}\par
102 {\cf21             TaskMgr.yieldForMessage(msto);  \\}\par
103 {\cf21         case n:  ; \}}\par
104 \par
123 {\cf21 #define TM_ADDSUBTASK(id, task) TaskMgr.addAutoWaitMessage(id, task);}\par
124 \par
130 {\cf21 #define TM_BEGINSUB()                       \\}\par
131 {\cf21     static byte __callingTask__;            \\}\par
132 {\cf21     TM_BEGIN();                             \\}\par
133 {\cf21     TaskMgr.getSource(__callingTask__);}\par
134 \par
144 {\cf21 #define TM_BEGINSUB_P(vtype, vlocal)        \\}\par
145 {\cf21     static vtype vlocal;                    \\}\par
146 {\cf21     TM_BEGINSUB();                          \\}\par
147 {\cf21     memcpy((void*)&vlocal, TaskMgr.getMessage(), sizeof(vtype));}\par
148 \par
154 {\cf21 #define TM_RETURNSUB()  \{ TaskMgr.sendMessage(__callingTask__, NULL, 0); __tmNext__ = 0; return; \}}\par
155 \par
162 {\cf21 #define TM_CALL(n, taskId) \{ TaskMgr.sendMessage(taskId, NULL, 0); TM_YIELDMESSAGE(n); \}}\par
163 \par
177 {\cf21 #define TM_CALL_P(n, taskId, vparam)                                        \\}\par
178 {\cf21     \{   TaskMgr.sendMessage(taskId, (void*)&vparam, sizeof(vparam));        \\}\par
179 {\cf21         TM_YIELDMESSAGE(n);                                                 \\}\par
180 {\cf21     \}}\par
181 \par
186 {\cf21 #define TM_ENDSUB()                                 \\}\par
187 {\cf21         default:    break;                          \\}\par
188 {\cf21     \}                                               \\}\par
189 {\cf21     TaskMgr.sendMessage(__callingTask__, NULL, 0);  \\}\par
190 {\cf21     __tmNext__ = 0;}\par
191 \par
192 \par
206 {\cf21 #define TM_REENTRANT(paramType, allParams, localp)                                      \\}\par
207 {\cf21     paramType*  localp;                                                                 \\}\par
208 {\cf21     \{   bool __done;                                                                    \\}\par
209 {\cf21         int __i, __where;                                                               \\}\par
210 {\cf21         __done = false;                                                                 \\}\par
211 {\cf21         for(__i=0; allParams[__i].taskId!=0; __i++)                                     \\}\par
212 {\cf21             if(allParams[__i].taskId==TaskMgr.myId()) \{ __done=true; __where=__i; \}     \\}\par
213 {\cf21         if(__done) \{ localp = &(allParams[__where]);    \}                               \\}\par
214 {\cf21         else return;                                                                    \\}\par
215 {\cf21     \}}\par
217 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TaskManagerSub_2.h\par \pard\plain 
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef TASKMANAGER_H_INCLUDED}\par
2 {\cf21 #define TASKMANAGER_H_INCLUDED}\par
3 \par
4 {\cf21 #include <TaskManagerMacros_2.h>}\par
5 {\cf21 #include <TaskManagerCore_2.h>}\par
6 {\cf17 extern} TaskManager TaskMgr;\par
7 {\cf21 #endif }{\cf20 // TASKMANAGER_H_INCLUDED}\par
8 \par
9 \par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
