<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TaskManager: TaskManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TaskManager
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">A Task Manager for Arduinos</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_task_manager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TaskManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A cooperative multitasking manager.  
 <a href="class_task_manager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_task_manager_core_8h_source.html">TaskManagerCore.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a491dc7a77a5381675f614a411755ef64"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a491dc7a77a5381675f614a411755ef64">TaskManager</a> ()</td></tr>
<tr class="memdesc:a491dc7a77a5381675f614a411755ef64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, Creates an empty task.  <a href="class_task_manager.html#a491dc7a77a5381675f614a411755ef64">More...</a><br /></td></tr>
<tr class="separator:a491dc7a77a5381675f614a411755ef64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ecdd2b8a6b7545eae64da180ba80c53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a6ecdd2b8a6b7545eae64da180ba80c53">~TaskManager</a> ()</td></tr>
<tr class="memdesc:a6ecdd2b8a6b7545eae64da180ba80c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. Destroys the <a class="el" href="class_task_manager.html" title="A cooperative multitasking manager.">TaskManager</a>.  <a href="class_task_manager.html#a6ecdd2b8a6b7545eae64da180ba80c53">More...</a><br /></td></tr>
<tr class="separator:a6ecdd2b8a6b7545eae64da180ba80c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b88a62f061cbc8159a101844d8e5469"><td class="memItemLeft" align="right" valign="top"><a id="a2b88a62f061cbc8159a101844d8e5469"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>loop</b> ()</td></tr>
<tr class="separator:a2b88a62f061cbc8159a101844d8e5469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a2a6da977b9d586fd16d71ff9108e5"><td class="memItemLeft" align="right" valign="top">_TaskManagerTask *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a99a2a6da977b9d586fd16d71ff9108e5">findTaskById</a> (byte id)</td></tr>
<tr class="memdesc:a99a2a6da977b9d586fd16d71ff9108e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a task by its ID.  <a href="class_task_manager.html#a99a2a6da977b9d586fd16d71ff9108e5">More...</a><br /></td></tr>
<tr class="separator:a99a2a6da977b9d586fd16d71ff9108e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Adding a New Task</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods are used to add new tasks to the task list </p>
</div></td></tr>
<tr class="memitem:a65196b3d3d327a203ec51b9b68a39b4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a65196b3d3d327a203ec51b9b68a39b4a">add</a> (byte taskId, void(*fn)())</td></tr>
<tr class="memdesc:a65196b3d3d327a203ec51b9b68a39b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a simple task.  <a href="class_task_manager.html#a65196b3d3d327a203ec51b9b68a39b4a">More...</a><br /></td></tr>
<tr class="separator:a65196b3d3d327a203ec51b9b68a39b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1e82c4d967c66d8992ec2e99baaae7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a8d1e82c4d967c66d8992ec2e99baaae7">addWaitDelay</a> (byte taskId, void(*fn)(), unsigned long msDelay)</td></tr>
<tr class="memdesc:a8d1e82c4d967c66d8992ec2e99baaae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task that will be delayed before its first invocation.  <a href="class_task_manager.html#a8d1e82c4d967c66d8992ec2e99baaae7">More...</a><br /></td></tr>
<tr class="separator:a8d1e82c4d967c66d8992ec2e99baaae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645ff50a9656974b61e7774af4e5632c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a645ff50a9656974b61e7774af4e5632c">addWaitUntil</a> (byte taskId, void(*fn)(), unsigned long msWhen)</td></tr>
<tr class="memdesc:a645ff50a9656974b61e7774af4e5632c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task that will be delayed until a set system clock time before its first invocation.  <a href="class_task_manager.html#a645ff50a9656974b61e7774af4e5632c">More...</a><br /></td></tr>
<tr class="separator:a645ff50a9656974b61e7774af4e5632c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5abb11af80255547aa1ec31a77dfe5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#aef5abb11af80255547aa1ec31a77dfe5">addWaitMessage</a> (byte taskId, void(*fn)(), unsigned long timeout=0)</td></tr>
<tr class="memdesc:aef5abb11af80255547aa1ec31a77dfe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task that is waiting for a message.  <a href="class_task_manager.html#aef5abb11af80255547aa1ec31a77dfe5">More...</a><br /></td></tr>
<tr class="separator:aef5abb11af80255547aa1ec31a77dfe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d46a7527bc15f3ea4289d2bbb3663b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a1d46a7527bc15f3ea4289d2bbb3663b2">addWaitSignal</a> (byte taskId, void(*fn)(), byte sigNum, unsigned long timeout=0)</td></tr>
<tr class="memdesc:a1d46a7527bc15f3ea4289d2bbb3663b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task that will wait until a signal arrives or (optionally) a timeout occurs.  <a href="class_task_manager.html#a1d46a7527bc15f3ea4289d2bbb3663b2">More...</a><br /></td></tr>
<tr class="separator:a1d46a7527bc15f3ea4289d2bbb3663b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee330530f268b857d18ac33ce9e6f8f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#aee330530f268b857d18ac33ce9e6f8f3">addAutoWaitDelay</a> (byte taskId, void(*fn)(), unsigned long period, bool startDelayed=false)</td></tr>
<tr class="memdesc:aee330530f268b857d18ac33ce9e6f8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task that will automatically reschedule itself with a delay.  <a href="class_task_manager.html#aee330530f268b857d18ac33ce9e6f8f3">More...</a><br /></td></tr>
<tr class="separator:aee330530f268b857d18ac33ce9e6f8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996a483a57bee67434279eb95168a330"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a996a483a57bee67434279eb95168a330">addAutoWaitSignal</a> (byte taskId, void(*fn)(), byte sigNum, unsigned long timeout=0, bool startWaiting=true)</td></tr>
<tr class="memdesc:a996a483a57bee67434279eb95168a330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task that will be delayed until a set system clock time before its first invocation, and will automatically reschedule itself with the same delay.  <a href="class_task_manager.html#a996a483a57bee67434279eb95168a330">More...</a><br /></td></tr>
<tr class="separator:a996a483a57bee67434279eb95168a330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d9a4165e19f96637b684a245fa985e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#ab8d9a4165e19f96637b684a245fa985e">addAutoWaitMessage</a> (byte taskId, void(*fn)(), unsigned long timeout=0, bool startWaiting=true)</td></tr>
<tr class="memdesc:ab8d9a4165e19f96637b684a245fa985e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task that is waiting for a message or until a timeout occurs.  <a href="class_task_manager.html#ab8d9a4165e19f96637b684a245fa985e">More...</a><br /></td></tr>
<tr class="separator:ab8d9a4165e19f96637b684a245fa985e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Yield</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods are used to yield control back to the task manager core. </p><dl class="section note"><dt>Note</dt><dd>Upon next invocation, execution will start at the TOP of the routine, not at the statement following the yield. </dd>
<dd>
A <em>yield</em> call will override any of the <em>addAuto...</em> automatic rescheduling. This will be a one-time override; later (non-<em>yield</em>) returns will resume automatic rescheduling. </dd></dl>
</div></td></tr>
<tr class="memitem:abc4f2e57cdc1fd1d3051b58dc816de98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#abc4f2e57cdc1fd1d3051b58dc816de98">yield</a> ()</td></tr>
<tr class="memdesc:abc4f2e57cdc1fd1d3051b58dc816de98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit from this task and return control to the task manager.  <a href="class_task_manager.html#abc4f2e57cdc1fd1d3051b58dc816de98">More...</a><br /></td></tr>
<tr class="separator:abc4f2e57cdc1fd1d3051b58dc816de98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2123fa0af84c3a1373b9437e2157e872"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a2123fa0af84c3a1373b9437e2157e872">yieldDelay</a> (unsigned long ms)</td></tr>
<tr class="memdesc:a2123fa0af84c3a1373b9437e2157e872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit from the task manager and do not restart this task until after a specified period.  <a href="class_task_manager.html#a2123fa0af84c3a1373b9437e2157e872">More...</a><br /></td></tr>
<tr class="separator:a2123fa0af84c3a1373b9437e2157e872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f827ee35d80bc4faa2f7d438163e78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#aa3f827ee35d80bc4faa2f7d438163e78">yieldUntil</a> (unsigned long when)</td></tr>
<tr class="memdesc:aa3f827ee35d80bc4faa2f7d438163e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit from the task manager and do not restart this task until (after) a specified CPU clock time.  <a href="class_task_manager.html#aa3f827ee35d80bc4faa2f7d438163e78">More...</a><br /></td></tr>
<tr class="separator:aa3f827ee35d80bc4faa2f7d438163e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887541b9c53d4dab1e28779098f68ce2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a887541b9c53d4dab1e28779098f68ce2">yieldForSignal</a> (byte sigNum, unsigned long timeout=0)</td></tr>
<tr class="memdesc:a887541b9c53d4dab1e28779098f68ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit from the task manager and do not restart this task until a signal has been received or a stated time period has passed.  <a href="class_task_manager.html#a887541b9c53d4dab1e28779098f68ce2">More...</a><br /></td></tr>
<tr class="separator:a887541b9c53d4dab1e28779098f68ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f368a9141c55b085aefdc8833aeaeec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a4f368a9141c55b085aefdc8833aeaeec">yieldForMessage</a> (unsigned long timeout=0)</td></tr>
<tr class="memdesc:a4f368a9141c55b085aefdc8833aeaeec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit from the task manager and do not restart this task until a message has been received or a stated time period has passed.  <a href="class_task_manager.html#a4f368a9141c55b085aefdc8833aeaeec">More...</a><br /></td></tr>
<tr class="separator:a4f368a9141c55b085aefdc8833aeaeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Sending Signals and Messages</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods send signals or messages to other tasks running on this or other nodes </p><dl class="section note"><dt>Note</dt><dd>If the nodeID is 0 on any routine that sends signals/messages to other nodes, the signal/message will be sent to this node. </dd></dl>
</div></td></tr>
<tr class="memitem:a7498109c70ab6189c18565c633533404"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a7498109c70ab6189c18565c633533404">sendSignal</a> (byte sigNum)</td></tr>
<tr class="memdesc:a7498109c70ab6189c18565c633533404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a signal to a task.  <a href="class_task_manager.html#a7498109c70ab6189c18565c633533404">More...</a><br /></td></tr>
<tr class="separator:a7498109c70ab6189c18565c633533404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a7b2a2c2f92f97da186bb3f2f19f9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#ab8a7b2a2c2f92f97da186bb3f2f19f9b">sendSignalAll</a> (byte sigNum)</td></tr>
<tr class="memdesc:ab8a7b2a2c2f92f97da186bb3f2f19f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a signal to all tasks that are waiting for this particular signal.  <a href="class_task_manager.html#ab8a7b2a2c2f92f97da186bb3f2f19f9b">More...</a><br /></td></tr>
<tr class="separator:ab8a7b2a2c2f92f97da186bb3f2f19f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa64288296449953f690b50935891f07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#afa64288296449953f690b50935891f07">sendMessage</a> (byte taskId, char *message)</td></tr>
<tr class="memdesc:afa64288296449953f690b50935891f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a string message to a task.  <a href="class_task_manager.html#afa64288296449953f690b50935891f07">More...</a><br /></td></tr>
<tr class="separator:afa64288296449953f690b50935891f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af332a07dcf5a649aabd22e57b2038e58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#af332a07dcf5a649aabd22e57b2038e58">sendMessage</a> (byte taskId, void *buf, int len)</td></tr>
<tr class="memdesc:af332a07dcf5a649aabd22e57b2038e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a binary message to a task.  <a href="class_task_manager.html#af332a07dcf5a649aabd22e57b2038e58">More...</a><br /></td></tr>
<tr class="separator:af332a07dcf5a649aabd22e57b2038e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e1a0b27ea28b7d0b4394da1d1b5ab0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#ac0e1a0b27ea28b7d0b4394da1d1b5ab0">getSource</a> (byte &amp;fromTaskId)</td></tr>
<tr class="memdesc:ac0e1a0b27ea28b7d0b4394da1d1b5ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get source node/task of last message/signal.  <a href="class_task_manager.html#ac0e1a0b27ea28b7d0b4394da1d1b5ab0">More...</a><br /></td></tr>
<tr class="separator:ac0e1a0b27ea28b7d0b4394da1d1b5ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Task Management</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Change task types</p>
<p>These routines change the scheduling metod for the given task. FOr example, SetAutoWaitDelay() will change a task so it will automatically wait for the set delay period after yielding (instead of using whatever rescheduling process was defined when it was Add()ed).</p>
<p>The change will take place immediately. If it is being performed on the currernt task, it will impact the next yield/return. If it is performed on a suspended task, the suspended tasks's reawakening constraints will be reset to the new method. </p>
</div></td></tr>
<tr class="memitem:af7ffb2b405dc4b78ec918345367509c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#af7ffb2b405dc4b78ec918345367509c0">suspend</a> (byte taskId)</td></tr>
<tr class="memdesc:af7ffb2b405dc4b78ec918345367509c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend the given task.  <a href="class_task_manager.html#af7ffb2b405dc4b78ec918345367509c0">More...</a><br /></td></tr>
<tr class="separator:af7ffb2b405dc4b78ec918345367509c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f938f2b80ae5cb0bb3365fa5ddaa0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#aa5f938f2b80ae5cb0bb3365fa5ddaa0a">resume</a> (byte taskId)</td></tr>
<tr class="memdesc:aa5f938f2b80ae5cb0bb3365fa5ddaa0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume the given task on the given node.  <a href="class_task_manager.html#aa5f938f2b80ae5cb0bb3365fa5ddaa0a">More...</a><br /></td></tr>
<tr class="separator:aa5f938f2b80ae5cb0bb3365fa5ddaa0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous and Informational Routines</div></td></tr>
<tr class="memitem:a966e7f218ea93bfb36020814ed489517"><td class="memItemLeft" align="right" valign="top"><a id="a966e7f218ea93bfb36020814ed489517"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a966e7f218ea93bfb36020814ed489517">runtime</a> () const</td></tr>
<tr class="memdesc:a966e7f218ea93bfb36020814ed489517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the time since the start of the run, in milliseconds. <br /></td></tr>
<tr class="separator:a966e7f218ea93bfb36020814ed489517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7641b79a5efb0a5e640daa8f623fa5c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#ae7641b79a5efb0a5e640daa8f623fa5c">timedOut</a> ()</td></tr>
<tr class="memdesc:ae7641b79a5efb0a5e640daa8f623fa5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if the current task has timed out while waiting for a signal or message.  <a href="class_task_manager.html#ae7641b79a5efb0a5e640daa8f623fa5c">More...</a><br /></td></tr>
<tr class="separator:ae7641b79a5efb0a5e640daa8f623fa5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a70749690f57b64c4db036abf1fa9d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#ab7a70749690f57b64c4db036abf1fa9d">getMessage</a> ()</td></tr>
<tr class="memdesc:ab7a70749690f57b64c4db036abf1fa9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a task's message buffer.  <a href="class_task_manager.html#ab7a70749690f57b64c4db036abf1fa9d">More...</a><br /></td></tr>
<tr class="separator:ab7a70749690f57b64c4db036abf1fa9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aae8179ea07541745321481de45aa68"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a9aae8179ea07541745321481de45aa68">myId</a> ()</td></tr>
<tr class="memdesc:a9aae8179ea07541745321481de45aa68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the task ID of the currently running task.  <a href="class_task_manager.html#a9aae8179ea07541745321481de45aa68">More...</a><br /></td></tr>
<tr class="separator:a9aae8179ea07541745321481de45aa68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a01f290a48b9f1f9ad4fdb08cffddaca5"><td class="memItemLeft" align="right" valign="top"><a id="a01f290a48b9f1f9ad4fdb08cffddaca5"></a>
<a class="el" href="classring.html">ring</a>&lt; _TaskManagerTask &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a01f290a48b9f1f9ad4fdb08cffddaca5">m_theTasks</a></td></tr>
<tr class="memdesc:a01f290a48b9f1f9ad4fdb08cffddaca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ring of all tasks. For internal use only. <br /></td></tr>
<tr class="separator:a01f290a48b9f1f9ad4fdb08cffddaca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aeb99707a6810f6f72cdcd5a6bfe0e232"><td class="memItemLeft" align="right" valign="top"><a id="aeb99707a6810f6f72cdcd5a6bfe0e232"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>internalSendSignal</b> (tm_nodeId_t fromNodeId, byte fromTaskId, byte sigNum)</td></tr>
<tr class="separator:aeb99707a6810f6f72cdcd5a6bfe0e232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51306491cd64992374a696091e49d601"><td class="memItemLeft" align="right" valign="top"><a id="a51306491cd64992374a696091e49d601"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>internalSendSignalAll</b> (tm_nodeId_t fromNodeId, byte fromTaskId, byte sigNum)</td></tr>
<tr class="separator:a51306491cd64992374a696091e49d601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15614bbd53084cf80df2ca67a3d729db"><td class="memItemLeft" align="right" valign="top"><a id="a15614bbd53084cf80df2ca67a3d729db"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>internalSendMessage</b> (tm_nodeId_t fromNodeId, byte fromTaskId, byte taskId, char *message)</td></tr>
<tr class="separator:a15614bbd53084cf80df2ca67a3d729db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09ec0fa21dfe2c540521b31d140cde3"><td class="memItemLeft" align="right" valign="top"><a id="ac09ec0fa21dfe2c540521b31d140cde3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>internalSendMessage</b> (tm_nodeId_t fromNodeId, byte fromTaskId, byte taskId, void *buf, int len)</td></tr>
<tr class="separator:ac09ec0fa21dfe2c540521b31d140cde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A cooperative multitasking manager. </p>
<p>Manages a set of cooperative tasks. This includes round-robin scheduling, yielding, and inter-task messaging and signaling. It also replaces the loop() function in standard Arduino programs. Nominally, there is a single instance of <a class="el" href="class_task_manager.html" title="A cooperative multitasking manager.">TaskManager</a> called TaskMgr. TaskMgr is used for all actual task control.</p>
<p>Each task has a taskID. By convention, user tasks' taskID values are in the range [0 127]. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a491dc7a77a5381675f614a411755ef64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491dc7a77a5381675f614a411755ef64">&#9670;&nbsp;</a></span>TaskManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TaskManager::TaskManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor, Creates an empty task. </p>
<p>Print out information about the task. </p>

</div>
</div>
<a id="a6ecdd2b8a6b7545eae64da180ba80c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ecdd2b8a6b7545eae64da180ba80c53">&#9670;&nbsp;</a></span>~TaskManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TaskManager::~TaskManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. Destroys the <a class="el" href="class_task_manager.html" title="A cooperative multitasking manager.">TaskManager</a>. </p>
<p>After calling this, any operations based on the object will fail. For normal purpoases, destroying the TaskMgr instance will have serious consequences for the standard loop() routine. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a65196b3d3d327a203ec51b9b68a39b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65196b3d3d327a203ec51b9b68a39b4a">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::add </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a simple task. </p>
<p>The task will execute once each cycle through the task list. Unless the task itself forces itself into a different scheduling model (e.g., through YieldSignal), it will execute again at the next available opportunity </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [1 239]. System tasks have taskId values in the range [240 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#a8d1e82c4d967c66d8992ec2e99baaae7" title="Add a task that will be delayed before its first invocation.">addWaitDelay</a>, <a class="el" href="class_task_manager.html#a645ff50a9656974b61e7774af4e5632c" title="Add a task that will be delayed until a set system clock time before its first invocation.">addWaitUntil</a>, <a class="el" href="class_task_manager.html#aee330530f268b857d18ac33ce9e6f8f3" title="Add a task that will automatically reschedule itself with a delay.">addAutoWaitDelay</a> </dd></dl>

</div>
</div>
<a id="aee330530f268b857d18ac33ce9e6f8f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee330530f268b857d18ac33ce9e6f8f3">&#9670;&nbsp;</a></span>addAutoWaitDelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::addAutoWaitDelay </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startDelayed</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task that will automatically reschedule itself with a delay. </p>
<p>This task will execute once each cycle. The task will automatically reschedule itself to not execute until the given delay has passed. The first execution may be delayed using the optional fourth parameter startDelayed. This delay, if used, will be the same as the period.</p>
<p>Note that yielding for messages or signals may extend this delay. However, if a signal/message is received during the delay period., the procedure will still wait until the end of the delay period. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
    <tr><td class="paramname">period</td><td>&ndash; the schedule, in milliseconds </td></tr>
    <tr><td class="paramname">startDelayed</td><td>&ndash; for the first execution, start immediately (false), or delay its start for one period (true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#a65196b3d3d327a203ec51b9b68a39b4a" title="Add a simple task.">add</a>, addDelayed, <a class="el" href="class_task_manager.html#a645ff50a9656974b61e7774af4e5632c" title="Add a task that will be delayed until a set system clock time before its first invocation.">addWaitUntil</a> </dd></dl>

</div>
</div>
<a id="ab8d9a4165e19f96637b684a245fa985e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d9a4165e19f96637b684a245fa985e">&#9670;&nbsp;</a></span>addAutoWaitMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::addAutoWaitMessage </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startWaiting</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task that is waiting for a message or until a timeout occurs. </p>
<p>The task will be added, but will be set to be waiting for the listed signal. If the signal does not arrive before the timeout period (in milliseconds), then the routine will be activated. The routine may use <a class="el" href="class_task_manager.html#ae7641b79a5efb0a5e640daa8f623fa5c" title="Tell if the current task has timed out while waiting for a signal or message.">TaskManager::timedOut()</a> to determine whether it timed our or received the signal. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
    <tr><td class="paramname">timeout</td><td>&ndash; the maximum time to wait (in ms) before timing out. </td></tr>
    <tr><td class="paramname">startWaiting</td><td>&ndash; tells whether the routine will start waiting for the signal (true) or will execute immediately (false). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#aef5abb11af80255547aa1ec31a77dfe5" title="Add a task that is waiting for a message.">addWaitMessage</a> </dd></dl>

</div>
</div>
<a id="a996a483a57bee67434279eb95168a330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996a483a57bee67434279eb95168a330">&#9670;&nbsp;</a></span>addAutoWaitSignal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::addAutoWaitSignal </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>sigNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startWaiting</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task that will be delayed until a set system clock time before its first invocation, and will automatically reschedule itself with the same delay. </p>
<p>The task will be added, but will be set to be waiting for the specified period. If the task exits normally (normal return, fall out of the bottom, or <a class="el" href="class_task_manager.html#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager.">yield()</a>), it will reschedule itself to wait for the same delay period. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
    <tr><td class="paramname">period</td><td>&ndash; the delay between invocations. </td></tr>
    <tr><td class="paramname">startWaiting</td><td>&ndash; tells whether the routine will start waiting for the signal (true) or will execute immediately (false). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d1e82c4d967c66d8992ec2e99baaae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1e82c4d967c66d8992ec2e99baaae7">&#9670;&nbsp;</a></span>addWaitDelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::addWaitDelay </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>msDelay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task that will be delayed before its first invocation. </p>
<p>This task will execute once each cycle. Its first execution will be delayed for a set time. After this, unless the task forces itself into a different scheduling model (e.g., through yieldSignal), it will execute agaion at the next available opportunity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
    <tr><td class="paramname">msDelay</td><td>&ndash; the initial delay, in milliseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#a65196b3d3d327a203ec51b9b68a39b4a" title="Add a simple task.">add</a>, <a class="el" href="class_task_manager.html#a645ff50a9656974b61e7774af4e5632c" title="Add a task that will be delayed until a set system clock time before its first invocation.">addWaitUntil</a>, <a class="el" href="class_task_manager.html#aee330530f268b857d18ac33ce9e6f8f3" title="Add a task that will automatically reschedule itself with a delay.">addAutoWaitDelay</a> </dd></dl>

</div>
</div>
<a id="aef5abb11af80255547aa1ec31a77dfe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5abb11af80255547aa1ec31a77dfe5">&#9670;&nbsp;</a></span>addWaitMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::addWaitMessage </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task that is waiting for a message. </p>
<p>The task will be added, but will be waiting for a message. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
    <tr><td class="paramname">timeout</td><td>&ndash; the maximum time to wait (in ms) before timing out. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d46a7527bc15f3ea4289d2bbb3663b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d46a7527bc15f3ea4289d2bbb3663b2">&#9670;&nbsp;</a></span>addWaitSignal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::addWaitSignal </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>sigNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task that will wait until a signal arrives or (optionally) a timeout occurs. </p>
<p>The task will be added, but will be set to be waiting for the listed signal. If a nonzero timeout is specified and ifthe signal does not arrive before the timeout period (in milliseconds), then the routine will be activated. The routine may use <a class="el" href="class_task_manager.html#ae7641b79a5efb0a5e640daa8f623fa5c" title="Tell if the current task has timed out while waiting for a signal or message.">TaskManager::timedOut()</a> to determine whether it timed our or received the signal.</p>
<p>Note that calling <a class="el" href="class_task_manager.html#a1d46a7527bc15f3ea4289d2bbb3663b2" title="Add a task that will wait until a signal arrives or (optionally) a timeout occurs.">addWaitSignal()</a> with no timeout or startWaiting parmeter, the task will start in a wait state with no timeout. To start the task in a non-wait-state (active) with no timeout, the routine must be called as addWaitSignal(id, fn, 0, false). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
    <tr><td class="paramname">sigNum</td><td>&ndash; the signal the task will be waiting for </td></tr>
    <tr><td class="paramname">timeout</td><td>&ndash; the maximum time to wait (in ms) before timing out. The default is zero (no timeout). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#a996a483a57bee67434279eb95168a330" title="Add a task that will be delayed until a set system clock time before its first invocation,...">addAutoWaitSignal</a> </dd></dl>

</div>
</div>
<a id="a645ff50a9656974b61e7774af4e5632c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645ff50a9656974b61e7774af4e5632c">&#9670;&nbsp;</a></span>addWaitUntil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::addWaitUntil </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>msWhen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task that will be delayed until a set system clock time before its first invocation. </p>
<p>This task will execute once each cycle. Its first execution will be delayed until a set system clock time. After this, unless the task forces itself into a different scheduling model (e.g., through yieldSignal), it will execute agaion at the next available opportunity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
    <tr><td class="paramname">msWhen</td><td>&ndash; the initial delay, in milliseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#a65196b3d3d327a203ec51b9b68a39b4a" title="Add a simple task.">add</a>, <a class="el" href="class_task_manager.html#a8d1e82c4d967c66d8992ec2e99baaae7" title="Add a task that will be delayed before its first invocation.">addWaitDelay</a>, <a class="el" href="class_task_manager.html#aee330530f268b857d18ac33ce9e6f8f3" title="Add a task that will automatically reschedule itself with a delay.">addAutoWaitDelay</a> </dd></dl>

</div>
</div>
<a id="a99a2a6da977b9d586fd16d71ff9108e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a2a6da977b9d586fd16d71ff9108e5">&#9670;&nbsp;</a></span>findTaskById()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_TaskManagerTask * TaskManager::findTaskById </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a task by its ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID of the task </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the _TaskManagerTask or NULL if not found </dd></dl>

</div>
</div>
<a id="ab7a70749690f57b64c4db036abf1fa9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a70749690f57b64c4db036abf1fa9d">&#9670;&nbsp;</a></span>getMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * TaskManager::getMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a task's message buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the actual message buffer. Use the contents of the buffer but do NOT modify it. If a task is killed, this pointer becomes invalid. </dd></dl>

</div>
</div>
<a id="ac0e1a0b27ea28b7d0b4394da1d1b5ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e1a0b27ea28b7d0b4394da1d1b5ab0">&#9670;&nbsp;</a></span>getSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::getSource </td>
          <td>(</td>
          <td class="paramtype">byte &amp;&#160;</td>
          <td class="paramname"><em>fromTaskId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get source node/task of last message/signal. </p>
<p>Returns the taskId of the task that last sent a signal or message to the current task. If the current task has never received a signal, returns [0].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">fromTaskId</td><td>&ndash; the taskId that sent the last message or signal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9aae8179ea07541745321481de45aa68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aae8179ea07541745321481de45aa68">&#9670;&nbsp;</a></span>myId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte TaskManager::myId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the task ID of the currently running task. </p>
<dl class="section return"><dt>Returns</dt><dd>The byte value that represents the current task's ID. </dd></dl>

</div>
</div>
<a id="aa5f938f2b80ae5cb0bb3365fa5ddaa0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f938f2b80ae5cb0bb3365fa5ddaa0a">&#9670;&nbsp;</a></span>resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::resume </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>taskId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume the given task on the given node. </p>
<p>Resumes a task. If the task do not exist, nothing happens. If the task had not been suspended, nothing happens. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>The task to be resumed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Not implemented. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#af7ffb2b405dc4b78ec918345367509c0" title="Suspend the given task.">suspend()</a> </dd></dl>

</div>
</div>
<a id="afa64288296449953f690b50935891f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa64288296449953f690b50935891f07">&#9670;&nbsp;</a></span>sendMessage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::sendMessage </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a string message to a task. </p>
<p>Sends a message to a task. The message will go to only one task.</p>
<p>Note that once a task has been sent a message, it will not be waiting for other instances of the same siggnal number. Note that additional messages sent prior to the task executing will overwrite any prior messages. Messages that are too large are ignored. Remember to account for the trailing '<br  />
' when considering the string message size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>&ndash; the ID number of the task </td></tr>
    <tr><td class="paramname">message</td><td>&ndash; the character string message. It is restricted in length to TASKMGR_MESSAGE_LENGTH-1 characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#a4f368a9141c55b085aefdc8833aeaeec" title="Exit from the task manager and do not restart this task until a message has been received or a stated...">yieldForMessage()</a> </dd></dl>

</div>
</div>
<a id="af332a07dcf5a649aabd22e57b2038e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af332a07dcf5a649aabd22e57b2038e58">&#9670;&nbsp;</a></span>sendMessage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::sendMessage </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a binary message to a task. </p>
<p>Sends a message to a task. The message will go to only one task. Note that once a task has been sent a message, it will not be waiting for other instances of the same signal number. Messages that are too large are ignored.</p>
<p>Note that additional messages sent prior to the task executing will overwrite any prior messages. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>&ndash; the ID number of the task </td></tr>
    <tr><td class="paramname">buf</td><td>&ndash; A pointer to the structure that is to be passed to the task </td></tr>
    <tr><td class="paramname">len</td><td>&ndash; The length of the buffer. Buffers can be at most TASKMGR_MESSAGE_LENGTH bytes long. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#a4f368a9141c55b085aefdc8833aeaeec" title="Exit from the task manager and do not restart this task until a message has been received or a stated...">yieldForMessage()</a> </dd></dl>

</div>
</div>
<a id="a7498109c70ab6189c18565c633533404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7498109c70ab6189c18565c633533404">&#9670;&nbsp;</a></span>sendSignal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::sendSignal </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>sigNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a signal to a task. </p>
<p>Sends a signal to a task. The signal will go to only one task. If there are several tasks waiting on the signal, it will go to the first task found that is waiting for this particular signal. Note that once a task is signalled, it will not be waiting for other instances of the same siggnal number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sigNum</td><td>&ndash; the value of the signal to be sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#a887541b9c53d4dab1e28779098f68ce2" title="Exit from the task manager and do not restart this task until a signal has been received or a stated ...">yieldForSignal()</a>, <a class="el" href="class_task_manager.html#ab8a7b2a2c2f92f97da186bb3f2f19f9b" title="Send a signal to all tasks that are waiting for this particular signal.">sendSignalAll()</a>, <a class="el" href="class_task_manager.html#a1d46a7527bc15f3ea4289d2bbb3663b2" title="Add a task that will wait until a signal arrives or (optionally) a timeout occurs.">addWaitSignal</a>, <a class="el" href="class_task_manager.html#a996a483a57bee67434279eb95168a330" title="Add a task that will be delayed until a set system clock time before its first invocation,...">addAutoWaitSignal()</a> </dd></dl>

</div>
</div>
<a id="ab8a7b2a2c2f92f97da186bb3f2f19f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a7b2a2c2f92f97da186bb3f2f19f9b">&#9670;&nbsp;</a></span>sendSignalAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::sendSignalAll </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>sigNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a signal to all tasks that are waiting for this particular signal. </p>
<p>Signals all tasks that are waiting for signal <em>sigNum</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sigNum</td><td>&ndash; The signal number to be sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#a7498109c70ab6189c18565c633533404" title="Sends a signal to a task.">sendSignal()</a>, yieldForSiganl(), <a class="el" href="class_task_manager.html#a1d46a7527bc15f3ea4289d2bbb3663b2" title="Add a task that will wait until a signal arrives or (optionally) a timeout occurs.">addWaitSignal()</a>, <a class="el" href="class_task_manager.html#a996a483a57bee67434279eb95168a330" title="Add a task that will be delayed until a set system clock time before its first invocation,...">addAutoWaitSignal()</a> </dd></dl>

</div>
</div>
<a id="af7ffb2b405dc4b78ec918345367509c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ffb2b405dc4b78ec918345367509c0">&#9670;&nbsp;</a></span>suspend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::suspend </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>taskId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend the given task. </p>
<p>The given task will be suspended until it is resumed. It will not be allowed to run, nor will it receive messages or signals. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>The task to be suspended</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Not implemented.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>receive </dd></dl>

</div>
</div>
<a id="ae7641b79a5efb0a5e640daa8f623fa5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7641b79a5efb0a5e640daa8f623fa5c">&#9670;&nbsp;</a></span>timedOut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TaskManager::timedOut </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell if the current task has timed out while waiting for a signal or message. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the task started due to timing out while waiting for a signal or message; false otherwise. </dd></dl>

</div>
</div>
<a id="abc4f2e57cdc1fd1d3051b58dc816de98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4f2e57cdc1fd1d3051b58dc816de98">&#9670;&nbsp;</a></span>yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::yield </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit from this task and return control to the task manager. </p>
<p>This exits from the current task, and returns control to the task manager. Functionally, it is similar to a return statement. The next time the task gains control, it will resume from the TOP of the routine. Note that if the task was an Auto task, it will be automatically rescheduled according to its Auto specifications. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#a2123fa0af84c3a1373b9437e2157e872" title="Exit from the task manager and do not restart this task until after a specified period.">yieldDelay()</a>, <a class="el" href="class_task_manager.html#aa3f827ee35d80bc4faa2f7d438163e78" title="Exit from the task manager and do not restart this task until (after) a specified CPU clock time.">yieldUntil()</a>, yieldSignal(), yieldMessage(), <a class="el" href="class_task_manager.html#aee330530f268b857d18ac33ce9e6f8f3" title="Add a task that will automatically reschedule itself with a delay.">addAutoWaitDelay()</a>, <a class="el" href="class_task_manager.html#a996a483a57bee67434279eb95168a330" title="Add a task that will be delayed until a set system clock time before its first invocation,...">addAutoWaitSignal()</a>, <a class="el" href="class_task_manager.html#ab8d9a4165e19f96637b684a245fa985e" title="Add a task that is waiting for a message or until a timeout occurs.">addAutoWaitMessage()</a> </dd></dl>

</div>
</div>
<a id="a2123fa0af84c3a1373b9437e2157e872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2123fa0af84c3a1373b9437e2157e872">&#9670;&nbsp;</a></span>yieldDelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::yieldDelay </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit from the task manager and do not restart this task until after a specified period. </p>
<p>This exits from the current task and returns control to the task manager. This task will not be rescheduled until at least the stated number of milliseconds has passed. Note that yieldDelay <em>overrides</em> any of the Auto specifications. That is, the next rescheduling will occur <em>solely</em> after the stated time period, and will not be constrained by AutoWaitSignal, AutoWaitMessage, or a different AutoWaitDelay value. The Auto specification will be retained, and will be applied on future executions where <a class="el" href="class_task_manager.html#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager.">yield()</a> or a normal return are used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>&ndash; the delay in milliseconds. Note the next call may exceed this constraint depending on time taken by other tasks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager.">yield()</a>, <a class="el" href="class_task_manager.html#aa3f827ee35d80bc4faa2f7d438163e78" title="Exit from the task manager and do not restart this task until (after) a specified CPU clock time.">yieldUntil()</a>, yieldSignal(), yieldMessage(), <a class="el" href="class_task_manager.html#aee330530f268b857d18ac33ce9e6f8f3" title="Add a task that will automatically reschedule itself with a delay.">addAutoWaitDelay()</a>, <a class="el" href="class_task_manager.html#a996a483a57bee67434279eb95168a330" title="Add a task that will be delayed until a set system clock time before its first invocation,...">addAutoWaitSignal()</a>, <a class="el" href="class_task_manager.html#ab8d9a4165e19f96637b684a245fa985e" title="Add a task that is waiting for a message or until a timeout occurs.">addAutoWaitMessage()</a> </dd></dl>

</div>
</div>
<a id="a4f368a9141c55b085aefdc8833aeaeec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f368a9141c55b085aefdc8833aeaeec">&#9670;&nbsp;</a></span>yieldForMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::yieldForMessage </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit from the task manager and do not restart this task until a message has been received or a stated time period has passed. </p>
<p>This exits from the current task and returns control to the task manager. This task will not be rescheduled until a message has been received or a stated time period has passed (the timeout period). The TaskManager::timeOut() function will tell whether or not the timeout had been triggered.</p>
<p>Note that yieldForMessage <em>overrides</em> any of the Auto specifications. That is, the next rescheduling will occur <em>solely</em> after the signal has been received, and will not be constrained by AutoWaitDelay, AutoWaitSignal, or a different AutoWaitMessage value. The Auto specification will be retained, and will be applied on future executions where <a class="el" href="class_task_manager.html#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager.">yield()</a> or a normal return are used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>&ndash; The timeout period, in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager.">yield()</a>, <a class="el" href="class_task_manager.html#a2123fa0af84c3a1373b9437e2157e872" title="Exit from the task manager and do not restart this task until after a specified period.">yieldDelay()</a>, <a class="el" href="class_task_manager.html#a887541b9c53d4dab1e28779098f68ce2" title="Exit from the task manager and do not restart this task until a signal has been received or a stated ...">yieldForSignal()</a>, <a class="el" href="class_task_manager.html#aee330530f268b857d18ac33ce9e6f8f3" title="Add a task that will automatically reschedule itself with a delay.">addAutoWaitDelay()</a>, <a class="el" href="class_task_manager.html#a996a483a57bee67434279eb95168a330" title="Add a task that will be delayed until a set system clock time before its first invocation,...">addAutoWaitSignal()</a>, <a class="el" href="class_task_manager.html#ab8d9a4165e19f96637b684a245fa985e" title="Add a task that is waiting for a message or until a timeout occurs.">addAutoWaitMessage()</a>, timeOut() </dd></dl>

</div>
</div>
<a id="a887541b9c53d4dab1e28779098f68ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887541b9c53d4dab1e28779098f68ce2">&#9670;&nbsp;</a></span>yieldForSignal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::yieldForSignal </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>sigNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit from the task manager and do not restart this task until a signal has been received or a stated time period has passed. </p>
<p>This exits from the current task and returns control to the task manager. This task will not be rescheduled until the given signal has been received or a stated time period has passed (the timeout period). The TaskManager::timeOut() function will tell whether or not the timeout had been triggered.</p>
<p>Note that yieldForSignal <em>overrides</em> any of the Auto specifications. That is, the next rescheduling will occur <em>solely</em> after the signal has been received, and will not be constrained by AutoWaitDelay, AutoWaitMessage, or a different AutoWaitSignal value. The Auto specification will be retained, and will be applied on future executions where <a class="el" href="class_task_manager.html#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager.">yield()</a> or a normal return are used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sigNum</td><td>&ndash; the value of the signal the task will wait for. </td></tr>
    <tr><td class="paramname">timeout</td><td>&ndash; The timeout period, in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager.">yield()</a>, <a class="el" href="class_task_manager.html#a2123fa0af84c3a1373b9437e2157e872" title="Exit from the task manager and do not restart this task until after a specified period.">yieldDelay()</a>, <a class="el" href="class_task_manager.html#a4f368a9141c55b085aefdc8833aeaeec" title="Exit from the task manager and do not restart this task until a message has been received or a stated...">yieldForMessage()</a>, <a class="el" href="class_task_manager.html#aee330530f268b857d18ac33ce9e6f8f3" title="Add a task that will automatically reschedule itself with a delay.">addAutoWaitDelay()</a>, <a class="el" href="class_task_manager.html#a996a483a57bee67434279eb95168a330" title="Add a task that will be delayed until a set system clock time before its first invocation,...">addAutoWaitSignal()</a>, <a class="el" href="class_task_manager.html#ab8d9a4165e19f96637b684a245fa985e" title="Add a task that is waiting for a message or until a timeout occurs.">addAutoWaitMessage()</a>, timeOut() </dd></dl>

</div>
</div>
<a id="aa3f827ee35d80bc4faa2f7d438163e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f827ee35d80bc4faa2f7d438163e78">&#9670;&nbsp;</a></span>yieldUntil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::yieldUntil </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>when</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit from the task manager and do not restart this task until (after) a specified CPU clock time. </p>
<p>This exits from the current task and returns control to the task manager. This task will not be rescheduled until the CPU clock (millis()) has exceeded the given time. Note that yieldUntil <em>overrides</em> any of the Auto specifications. That is, the next rescheduling will occur <em>solely</em> after the stated clock time has passed, and will not be constrained by AutoWaitSignal, AutoWaitMessage, or a different AutoWaitDelay value. The Auto specification will be retained, and will be applied on future executions where <a class="el" href="class_task_manager.html#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager.">yield()</a> or a normal return are used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">when</td><td>&ndash; The target CPU time. Note the next call may exceed this constraint depending on time taken by other tasks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager.">yield()</a>, <a class="el" href="class_task_manager.html#a2123fa0af84c3a1373b9437e2157e872" title="Exit from the task manager and do not restart this task until after a specified period.">yieldDelay()</a>, yieldSignal(), yieldMessage(), <a class="el" href="class_task_manager.html#aee330530f268b857d18ac33ce9e6f8f3" title="Add a task that will automatically reschedule itself with a delay.">addAutoWaitDelay()</a>, <a class="el" href="class_task_manager.html#a996a483a57bee67434279eb95168a330" title="Add a task that will be delayed until a set system clock time before its first invocation,...">addAutoWaitSignal()</a>, <a class="el" href="class_task_manager.html#ab8d9a4165e19f96637b684a245fa985e" title="Add a task that is waiting for a message or until a timeout occurs.">addAutoWaitMessage()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_task_manager_core_8h_source.html">TaskManagerCore.h</a></li>
<li><a class="el" href="_task_manager_8cpp.html">TaskManager.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Dec 29 2020 14:12:57 for TaskManager by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
