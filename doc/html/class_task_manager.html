<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TaskManager: TaskManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">TaskManager<span id="projectnumber">&#160;2.2</span>
   </div>
   <div id="projectbrief">A Task Manager for Arduinos</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="class_task_manager-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TaskManager Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A cooperative multitasking manager.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_task_manager_core_8h_source.html">TaskManagerCore.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Yield</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods are used to yield control back to the task manager core. </p><dl class="section note"><dt>Note</dt><dd>Upon next invocation, execution will start at the TOP of the routine, not at the statement following the yield. </dd>
<dd>
A <em>yield</em> call will override any of the <em>addAuto...</em> automatic rescheduling. This will be a one-time override; later (non-<em>yield</em>) returns will resume automatic rescheduling. </dd></dl>
</div></td></tr>
<tr class="memitem:abc4f2e57cdc1fd1d3051b58dc816de98" id="r_abc4f2e57cdc1fd1d3051b58dc816de98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc4f2e57cdc1fd1d3051b58dc816de98">yield</a> ()</td></tr>
<tr class="memdesc:abc4f2e57cdc1fd1d3051b58dc816de98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit from this task and return control to the task manager.  <br /></td></tr>
<tr class="separator:abc4f2e57cdc1fd1d3051b58dc816de98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2123fa0af84c3a1373b9437e2157e872" id="r_a2123fa0af84c3a1373b9437e2157e872"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2123fa0af84c3a1373b9437e2157e872">yieldDelay</a> (unsigned long ms)</td></tr>
<tr class="memdesc:a2123fa0af84c3a1373b9437e2157e872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit from the task manager and do not restart this task until after a specified period.  <br /></td></tr>
<tr class="separator:a2123fa0af84c3a1373b9437e2157e872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f827ee35d80bc4faa2f7d438163e78" id="r_aa3f827ee35d80bc4faa2f7d438163e78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3f827ee35d80bc4faa2f7d438163e78">yieldUntil</a> (unsigned long when)</td></tr>
<tr class="memdesc:aa3f827ee35d80bc4faa2f7d438163e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit from the task manager and do not restart this task until (after) a specified CPU clock time.  <br /></td></tr>
<tr class="separator:aa3f827ee35d80bc4faa2f7d438163e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f368a9141c55b085aefdc8833aeaeec" id="r_a4f368a9141c55b085aefdc8833aeaeec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f368a9141c55b085aefdc8833aeaeec">yieldForMessage</a> (unsigned long timeout=0)</td></tr>
<tr class="memdesc:a4f368a9141c55b085aefdc8833aeaeec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit from the task manager and do not restart this task until a message has been received or a stated time period has passed.  <br /></td></tr>
<tr class="separator:a4f368a9141c55b085aefdc8833aeaeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79227d756bef8d23a2be42ff60f1c606" id="r_a79227d756bef8d23a2be42ff60f1c606"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79227d756bef8d23a2be42ff60f1c606">sendMessage</a> (<a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a> taskId, char *message)</td></tr>
<tr class="memdesc:a79227d756bef8d23a2be42ff60f1c606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a string message to a task.  <br /></td></tr>
<tr class="separator:a79227d756bef8d23a2be42ff60f1c606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2668163bdcc5cd6057041cf766ed5e68" id="r_a2668163bdcc5cd6057041cf766ed5e68"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2668163bdcc5cd6057041cf766ed5e68">sendMessage</a> (<a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a> taskId, void *buf, int len)</td></tr>
<tr class="memdesc:a2668163bdcc5cd6057041cf766ed5e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a binary message to a task.  <br /></td></tr>
<tr class="separator:a2668163bdcc5cd6057041cf766ed5e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ba60f8681afab4cc32d16759262760" id="r_ae5ba60f8681afab4cc32d16759262760"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5ba60f8681afab4cc32d16759262760">sendMessage</a> (<a class="el" href="_task_manager_core_8h.html#a171e372bd267b282cf5a55106f4d18d2">tm_nodeId_t</a> nodeId, <a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a> taskId, char *message)</td></tr>
<tr class="memdesc:ae5ba60f8681afab4cc32d16759262760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a string message to a task on a different node.  <br /></td></tr>
<tr class="separator:ae5ba60f8681afab4cc32d16759262760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e041c5d9fad4453d24d18969123b07d" id="r_a8e041c5d9fad4453d24d18969123b07d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e041c5d9fad4453d24d18969123b07d">sendMessage</a> (<a class="el" href="_task_manager_core_8h.html#a171e372bd267b282cf5a55106f4d18d2">tm_nodeId_t</a> nodeId, <a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a> taskId, void *buf, int len)</td></tr>
<tr class="memdesc:a8e041c5d9fad4453d24d18969123b07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a binary message to a task on a different node.  <br /></td></tr>
<tr class="separator:a8e041c5d9fad4453d24d18969123b07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4e11619ef42339d1a20fa2d31b2b72" id="r_a0f4e11619ef42339d1a20fa2d31b2b72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f4e11619ef42339d1a20fa2d31b2b72">getSource</a> (<a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a> &amp;fromTaskId)</td></tr>
<tr class="memdesc:a0f4e11619ef42339d1a20fa2d31b2b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get task ID of last message's sender.  <br /></td></tr>
<tr class="separator:a0f4e11619ef42339d1a20fa2d31b2b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7883ae6d432125c5bdf3e354a1696b" id="r_a1d7883ae6d432125c5bdf3e354a1696b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d7883ae6d432125c5bdf3e354a1696b">getSource</a> (<a class="el" href="_task_manager_core_8h.html#a171e372bd267b282cf5a55106f4d18d2">tm_nodeId_t</a> &amp;fromNodeId, <a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a> &amp;fromTaskId)</td></tr>
<tr class="memdesc:a1d7883ae6d432125c5bdf3e354a1696b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get source node/task ID of last message.  <br /></td></tr>
<tr class="separator:a1d7883ae6d432125c5bdf3e354a1696b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Constructors and Destructors</h2></td></tr>
<tr class="memitem:a491dc7a77a5381675f614a411755ef64" id="r_a491dc7a77a5381675f614a411755ef64"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a491dc7a77a5381675f614a411755ef64">TaskManager</a> ()</td></tr>
<tr class="memdesc:a491dc7a77a5381675f614a411755ef64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out information about the task.  <br /></td></tr>
<tr class="separator:a491dc7a77a5381675f614a411755ef64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ecdd2b8a6b7545eae64da180ba80c53" id="r_a6ecdd2b8a6b7545eae64da180ba80c53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ecdd2b8a6b7545eae64da180ba80c53">~TaskManager</a> ()</td></tr>
<tr class="memdesc:a6ecdd2b8a6b7545eae64da180ba80c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an existing <a class="el" href="class_task_manager.html" title="A cooperative multitasking manager.">TaskManager</a> task control object.  <br /></td></tr>
<tr class="separator:a6ecdd2b8a6b7545eae64da180ba80c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b61b260f5ddd9676f7a6899da40ad9e" id="r_a3b61b260f5ddd9676f7a6899da40ad9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b61b260f5ddd9676f7a6899da40ad9e">add</a> (<a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a> taskId, void(*fn)())</td></tr>
<tr class="memdesc:a3b61b260f5ddd9676f7a6899da40ad9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">endcond  <br /></td></tr>
<tr class="separator:a3b61b260f5ddd9676f7a6899da40ad9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d87e94ca41ece59e98adba02ba8103" id="r_ad0d87e94ca41ece59e98adba02ba8103"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0d87e94ca41ece59e98adba02ba8103">addWaitDelay</a> (<a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a> taskId, void(*fn)(), unsigned long msDelay)</td></tr>
<tr class="memdesc:ad0d87e94ca41ece59e98adba02ba8103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task that will be delayed before its first invocation.  <br /></td></tr>
<tr class="separator:ad0d87e94ca41ece59e98adba02ba8103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8ccd8e7753e35a483dd8d9203ef8ca" id="r_aef8ccd8e7753e35a483dd8d9203ef8ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef8ccd8e7753e35a483dd8d9203ef8ca">addWaitUntil</a> (<a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a> taskId, void(*fn)(), unsigned long msWhen)</td></tr>
<tr class="memdesc:aef8ccd8e7753e35a483dd8d9203ef8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task that will be delayed until a set system clock time before its first invocation.  <br /></td></tr>
<tr class="separator:aef8ccd8e7753e35a483dd8d9203ef8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d58e9b9e596b19264bb2cbf7c02878" id="r_a41d58e9b9e596b19264bb2cbf7c02878"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41d58e9b9e596b19264bb2cbf7c02878">addAutoWaitDelay</a> (<a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a> taskId, void(*fn)(), unsigned long period, bool startDelayed=false)</td></tr>
<tr class="memdesc:a41d58e9b9e596b19264bb2cbf7c02878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task that will automatically reschedule itself with a delay.  <br /></td></tr>
<tr class="separator:a41d58e9b9e596b19264bb2cbf7c02878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b5017ee459e0d54a0995c084bd273f" id="r_a51b5017ee459e0d54a0995c084bd273f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51b5017ee459e0d54a0995c084bd273f">addWaitMessage</a> (<a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a> taskId, void(*fn)(), unsigned long timeout=0)</td></tr>
<tr class="memdesc:a51b5017ee459e0d54a0995c084bd273f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task that is waiting for a message.  <br /></td></tr>
<tr class="separator:a51b5017ee459e0d54a0995c084bd273f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4cd56685a46a66bb3b5a25c1ba8685" id="r_a2c4cd56685a46a66bb3b5a25c1ba8685"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c4cd56685a46a66bb3b5a25c1ba8685">addAutoWaitMessage</a> (<a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a> taskId, void(*fn)(), unsigned long timeout=0, bool startWaiting=true)</td></tr>
<tr class="memdesc:a2c4cd56685a46a66bb3b5a25c1ba8685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task that is waiting for a message or until a timeout occurs.  <br /></td></tr>
<tr class="separator:a2c4cd56685a46a66bb3b5a25c1ba8685"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Task Control</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Methods for suspending and resuming tasks </p>
</td></tr>
<tr class="memitem:ada5584ddd8b8f8e816153967619398e6" id="r_ada5584ddd8b8f8e816153967619398e6"><td class="memItemLeft" align="right" valign="top">SemaphoreHandle_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada5584ddd8b8f8e816153967619398e6">m_TaskManagerMessageQueueSemaphore</a></td></tr>
<tr class="separator:ada5584ddd8b8f8e816153967619398e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b85b2e38baa808ad06b039adff9142c" id="r_a0b85b2e38baa808ad06b039adff9142c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b85b2e38baa808ad06b039adff9142c">suspend</a> (<a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a> taskId)</td></tr>
<tr class="memdesc:a0b85b2e38baa808ad06b039adff9142c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend the given task on this node.  <br /></td></tr>
<tr class="separator:a0b85b2e38baa808ad06b039adff9142c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb954eabd1933e6e846285210fff088" id="r_a9bb954eabd1933e6e846285210fff088"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bb954eabd1933e6e846285210fff088">suspend</a> (<a class="el" href="_task_manager_core_8h.html#a171e372bd267b282cf5a55106f4d18d2">tm_nodeId_t</a> nodeId, <a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a> taskId)</td></tr>
<tr class="memdesc:a9bb954eabd1933e6e846285210fff088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend the given task on the given node.  <br /></td></tr>
<tr class="separator:a9bb954eabd1933e6e846285210fff088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf8c3e66349d6a15a3fe04f555c0480" id="r_a1bf8c3e66349d6a15a3fe04f555c0480"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1bf8c3e66349d6a15a3fe04f555c0480">resume</a> (<a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a> taskId)</td></tr>
<tr class="memdesc:a1bf8c3e66349d6a15a3fe04f555c0480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume the given task on this node.  <br /></td></tr>
<tr class="separator:a1bf8c3e66349d6a15a3fe04f555c0480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffabf2edb1ba7bc18785fc4217a3505" id="r_a6ffabf2edb1ba7bc18785fc4217a3505"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ffabf2edb1ba7bc18785fc4217a3505">resume</a> (<a class="el" href="_task_manager_core_8h.html#a171e372bd267b282cf5a55106f4d18d2">tm_nodeId_t</a> nodeId, <a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a> taskId)</td></tr>
<tr class="memdesc:a6ffabf2edb1ba7bc18785fc4217a3505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume the given task on the given node.  <br /></td></tr>
<tr class="separator:a6ffabf2edb1ba7bc18785fc4217a3505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0189a1b17878cb115126da8dcf7822ae" id="r_ga0189a1b17878cb115126da8dcf7822ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___task_manager_radio_e_s_p.html#ga0189a1b17878cb115126da8dcf7822ae">tmRadioReceiverTask</a> ()</td></tr>
<tr class="separator:ga0189a1b17878cb115126da8dcf7822ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa187de5f5ff98accacae03bf08653969" id="r_gaa187de5f5ff98accacae03bf08653969"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___task_manager_radio_e_s_p.html#gaa187de5f5ff98accacae03bf08653969">lastESPError</a> ()</td></tr>
<tr class="memdesc:gaa187de5f5ff98accacae03bf08653969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a textual description of the last ESP error message.  <br /></td></tr>
<tr class="separator:gaa187de5f5ff98accacae03bf08653969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379de9acea847cd98206bb82376a65bc" id="r_a379de9acea847cd98206bb82376a65bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a379de9acea847cd98206bb82376a65bc">radioBegin</a> (<a class="el" href="_task_manager_core_8h.html#a171e372bd267b282cf5a55106f4d18d2">tm_nodeId_t</a> nodeId, byte cePin, byte csPin)</td></tr>
<tr class="memdesc:a379de9acea847cd98206bb82376a65bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the radio and start it receiving.  <br /></td></tr>
<tr class="separator:a379de9acea847cd98206bb82376a65bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac745dd2b71d0d19a30f1fcfc486ae6bd" id="r_gac745dd2b71d0d19a30f1fcfc486ae6bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___task_manager_radio_e_s_p.html#gac745dd2b71d0d19a30f1fcfc486ae6bd">radioBegin</a> (<a class="el" href="_task_manager_core_8h.html#a171e372bd267b282cf5a55106f4d18d2">tm_nodeId_t</a> nodeId, const char *ssid=NULL, const char *pw=NULL)</td></tr>
<tr class="memdesc:gac745dd2b71d0d19a30f1fcfc486ae6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the radio and start it receiving.  <br /></td></tr>
<tr class="separator:gac745dd2b71d0d19a30f1fcfc486ae6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9123028970afdce95b07e76adcd4b4ce" id="r_ga9123028970afdce95b07e76adcd4b4ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___task_manager_radio_e_s_p.html#ga9123028970afdce95b07e76adcd4b4ce">registerPeer</a> (<a class="el" href="_task_manager_core_8h.html#a171e372bd267b282cf5a55106f4d18d2">tm_nodeId_t</a> nodeId)</td></tr>
<tr class="memdesc:ga9123028970afdce95b07e76adcd4b4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a peer for ESP-Now communications.  <br /></td></tr>
<tr class="separator:ga9123028970afdce95b07e76adcd4b4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa94433d55bbcb0093c7c842e037cd171" id="r_gaa94433d55bbcb0093c7c842e037cd171"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___task_manager_radio_e_s_p.html#gaa94433d55bbcb0093c7c842e037cd171">unRegisterPeer</a> (<a class="el" href="_task_manager_core_8h.html#a171e372bd267b282cf5a55106f4d18d2">tm_nodeId_t</a> nodeId)</td></tr>
<tr class="memdesc:gaa94433d55bbcb0093c7c842e037cd171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a peer from ESP-Now communications.  <br /></td></tr>
<tr class="separator:gaa94433d55bbcb0093c7c842e037cd171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab797d73ccb1b1a13c797bd1262249dea" id="r_ab797d73ccb1b1a13c797bd1262249dea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_task_manager_core_8h.html#a171e372bd267b282cf5a55106f4d18d2">tm_nodeId_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab797d73ccb1b1a13c797bd1262249dea">myNodeId</a> ()</td></tr>
<tr class="memdesc:ab797d73ccb1b1a13c797bd1262249dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the node ID of this system.  <br /></td></tr>
<tr class="separator:ab797d73ccb1b1a13c797bd1262249dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761fac56986635de2125f9b45441bcd3" id="r_a761fac56986635de2125f9b45441bcd3"><td class="memItemLeft" align="right" valign="top"><a id="a761fac56986635de2125f9b45441bcd3" name="a761fac56986635de2125f9b45441bcd3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> ()</td></tr>
<tr class="memdesc:a761fac56986635de2125f9b45441bcd3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_task_manager.html" title="A cooperative multitasking manager.">TaskManager</a> initialization. <br /></td></tr>
<tr class="separator:a761fac56986635de2125f9b45441bcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966e7f218ea93bfb36020814ed489517" id="r_a966e7f218ea93bfb36020814ed489517"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a966e7f218ea93bfb36020814ed489517">runtime</a> () const</td></tr>
<tr class="memdesc:a966e7f218ea93bfb36020814ed489517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the time since the start of the run, in milliseconds.  <br /></td></tr>
<tr class="separator:a966e7f218ea93bfb36020814ed489517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7641b79a5efb0a5e640daa8f623fa5c" id="r_ae7641b79a5efb0a5e640daa8f623fa5c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7641b79a5efb0a5e640daa8f623fa5c">timedOut</a> ()</td></tr>
<tr class="memdesc:ae7641b79a5efb0a5e640daa8f623fa5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if the current task has timed out while waiting for a message.  <br /></td></tr>
<tr class="separator:ae7641b79a5efb0a5e640daa8f623fa5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a70749690f57b64c4db036abf1fa9d" id="r_ab7a70749690f57b64c4db036abf1fa9d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7a70749690f57b64c4db036abf1fa9d">getMessage</a> ()</td></tr>
<tr class="memdesc:ab7a70749690f57b64c4db036abf1fa9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a task's message buffer.  <br /></td></tr>
<tr class="separator:ab7a70749690f57b64c4db036abf1fa9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2512563ba937a3542cbe564830ce1ae0" id="r_a2512563ba937a3542cbe564830ce1ae0"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2512563ba937a3542cbe564830ce1ae0">getMessageLength</a> ()</td></tr>
<tr class="memdesc:a2512563ba937a3542cbe564830ce1ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the message in the buffer.  <br /></td></tr>
<tr class="separator:a2512563ba937a3542cbe564830ce1ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087a0368a1dc5670757f56000b906e22" id="r_a087a0368a1dc5670757f56000b906e22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a087a0368a1dc5670757f56000b906e22">myId</a> ()</td></tr>
<tr class="memdesc:a087a0368a1dc5670757f56000b906e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the task ID of the currently running task.  <br /></td></tr>
<tr class="separator:a087a0368a1dc5670757f56000b906e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b88a62f061cbc8159a101844d8e5469" id="r_a2b88a62f061cbc8159a101844d8e5469"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b88a62f061cbc8159a101844d8e5469">loop</a> ()</td></tr>
<tr class="memdesc:a2b88a62f061cbc8159a101844d8e5469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a single pass for the system <a class="el" href="#a2b88a62f061cbc8159a101844d8e5469" title="Implements a single pass for the system loop() routine.">loop()</a> routine.  <br /></td></tr>
<tr class="separator:a2b88a62f061cbc8159a101844d8e5469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a15939190c8b370c1391963f5445d41" id="r_a4a15939190c8b370c1391963f5445d41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a15939190c8b370c1391963f5445d41">resync</a> (unsigned long remoteMillis)</td></tr>
<tr class="memdesc:a4a15939190c8b370c1391963f5445d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">resync Synchronize this node's <a class="el" href="#a2d05cc9618f108007073ebcab05a61f7" title="Synchronized millisecond clock This is the virtual network clock value. It is the local clock,...">millis()</a> timer to a remote time server node's <a class="el" href="#a2d05cc9618f108007073ebcab05a61f7" title="Synchronized millisecond clock This is the virtual network clock value. It is the local clock,...">millis()</a>  <br /></td></tr>
<tr class="separator:a4a15939190c8b370c1391963f5445d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d05cc9618f108007073ebcab05a61f7" id="r_a2d05cc9618f108007073ebcab05a61f7"><td class="memItemLeft" align="right" valign="top">unsigned long int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d05cc9618f108007073ebcab05a61f7">millis</a> () const</td></tr>
<tr class="memdesc:a2d05cc9618f108007073ebcab05a61f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronized millisecond clock This is the virtual network clock value. It is the local clock, adjusted by the recorded offset between the local clock and the network clock.  <br /></td></tr>
<tr class="separator:a2d05cc9618f108007073ebcab05a61f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9968aa8e895bfc0bbb0cd4e06ee14e6d" id="r_a9968aa8e895bfc0bbb0cd4e06ee14e6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class___task_manager_task.html">_TaskManagerTask</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9968aa8e895bfc0bbb0cd4e06ee14e6d">findTaskById</a> (<a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a> id)</td></tr>
<tr class="memdesc:a9968aa8e895bfc0bbb0cd4e06ee14e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a task by its ID. <br  />
  <br /></td></tr>
<tr class="separator:a9968aa8e895bfc0bbb0cd4e06ee14e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09bb6c7863e8d8f3744b8d6da95a56bf" id="r_a09bb6c7863e8d8f3744b8d6da95a56bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09bb6c7863e8d8f3744b8d6da95a56bf">internalSendMessage</a> (<a class="el" href="_task_manager_core_8h.html#a171e372bd267b282cf5a55106f4d18d2">tm_nodeId_t</a> fromNodeId, <a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a> fromTaskId, <a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a> taskId, char *message)</td></tr>
<tr class="memdesc:a09bb6c7863e8d8f3744b8d6da95a56bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a string message to a task on this system. Send a null-terminated (string) message to a task running on this system. This is the internal gateway used by both sendMessage("this node") and from the radio receiver module (messages from other nodes).  <br /></td></tr>
<tr class="separator:a09bb6c7863e8d8f3744b8d6da95a56bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b702e8ce9d59865dcc6b58742b8254b" id="r_a1b702e8ce9d59865dcc6b58742b8254b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b702e8ce9d59865dcc6b58742b8254b">internalSendMessage</a> (<a class="el" href="_task_manager_core_8h.html#a171e372bd267b282cf5a55106f4d18d2">tm_nodeId_t</a> fromNodeId, <a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a> fromTaskId, <a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a> taskId, void *buf, int len)</td></tr>
<tr class="memdesc:a1b702e8ce9d59865dcc6b58742b8254b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a binary message to a task on this system. Send a raw data (binary) message to a task running on this system. This is the internal gateway used by both sendMessage("this node") and from the radio receiver module (messages from other nodes).  <br /></td></tr>
<tr class="separator:a1b702e8ce9d59865dcc6b58742b8254b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Member Variables</h2></td></tr>
<tr class="memitem:a01f290a48b9f1f9ad4fdb08cffddaca5" id="r_a01f290a48b9f1f9ad4fdb08cffddaca5"><td class="memItemLeft" align="right" valign="top"><a id="a01f290a48b9f1f9ad4fdb08cffddaca5" name="a01f290a48b9f1f9ad4fdb08cffddaca5"></a>
<a class="el" href="classring.html">ring</a>&lt; <a class="el" href="class___task_manager_task.html">_TaskManagerTask</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_theTasks</b></td></tr>
<tr class="memdesc:a01f290a48b9f1f9ad4fdb08cffddaca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ring of all tasks. For internal use only. <br /></td></tr>
<tr class="separator:a01f290a48b9f1f9ad4fdb08cffddaca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A cooperative multitasking manager. </p>
<p>Manages a set of cooperative tasks. This includes round-robin scheduling, yielding, and inter-task messaging. It also replaces the <a class="el" href="#a2b88a62f061cbc8159a101844d8e5469" title="Implements a single pass for the system loop() routine.">loop()</a> function in standard Arduino programs. Nominally, there is a single instance of <a class="el" href="class_task_manager.html" title="A cooperative multitasking manager.">TaskManager</a> called TaskMgr. TaskMgr is used for all actual task control.</p>
<p>Each task has a taskID. By convention, user tasks' taskID values are in the range [0 223]. Task IDs [224 255] are reserved for system and common module tasks. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a491dc7a77a5381675f614a411755ef64" name="a491dc7a77a5381675f614a411755ef64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491dc7a77a5381675f614a411755ef64">&#9670;&#160;</a></span>TaskManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TaskManager::TaskManager </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out information about the task. </p>
<p>In a debugging environment (<a class="el" href="class_task_manager.html" title="A cooperative multitasking manager.">TaskManager</a> debugging is enabled), this will print out information on a single task.</p>
<p>Create a new <a class="el" href="class_task_manager.html" title="A cooperative multitasking manager.">TaskManager</a> task control object.</p>
<p>Creates an empty <a class="el" href="class_task_manager.html" title="A cooperative multitasking manager.">TaskManager</a> control object </p>

</div>
</div>
<a id="a6ecdd2b8a6b7545eae64da180ba80c53" name="a6ecdd2b8a6b7545eae64da180ba80c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ecdd2b8a6b7545eae64da180ba80c53">&#9670;&#160;</a></span>~TaskManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TaskManager::~TaskManager </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy an existing <a class="el" href="class_task_manager.html" title="A cooperative multitasking manager.">TaskManager</a> task control object. </p>
<p>Destroys a <a class="el" href="class_task_manager.html" title="A cooperative multitasking manager.">TaskManager</a> object. We do not expect this will ever be called, however, it is included for completeness. For normal purpoases, destroying the TaskMgr instance will have serious consequences for the standard <a class="el" href="#a2b88a62f061cbc8159a101844d8e5469" title="Implements a single pass for the system loop() routine.">loop()</a> routine. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3b61b260f5ddd9676f7a6899da40ad9e" name="a3b61b260f5ddd9676f7a6899da40ad9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b61b260f5ddd9676f7a6899da40ad9e">&#9670;&#160;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a></td>          <td class="paramname"><span class="paramname"><em>taskId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*</td>          <td class="paramname"><span class="paramname"><em>fn&#160;</em></span>)()&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>endcond </p>
<p>Add a simple task.</p>
<p>The task will execute once each cycle through the task list. Unless the task itself forces itself into a different scheduling model (e.g., through YieldMessage), it will execute again at the next available opportunity </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [1 239]. System tasks have taskId values in the range [240 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad0d87e94ca41ece59e98adba02ba8103" title="Add a task that will be delayed before its first invocation.">addWaitDelay</a>, <a class="el" href="#aef8ccd8e7753e35a483dd8d9203ef8ca" title="Add a task that will be delayed until a set system clock time before its first invocation.">addWaitUntil</a>, <a class="el" href="#a41d58e9b9e596b19264bb2cbf7c02878" title="Add a task that will automatically reschedule itself with a delay.">addAutoWaitDelay</a> </dd></dl>

</div>
</div>
<a id="a41d58e9b9e596b19264bb2cbf7c02878" name="a41d58e9b9e596b19264bb2cbf7c02878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d58e9b9e596b19264bb2cbf7c02878">&#9670;&#160;</a></span>addAutoWaitDelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::addAutoWaitDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a></td>          <td class="paramname"><span class="paramname"><em>taskId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*</td>          <td class="paramname"><span class="paramname"><em>fn&#160;</em></span>)(), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>period</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>startWaiting</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task that will automatically reschedule itself with a delay. </p>
<p>This task will execute once each cycle. The task will automatically reschedule itself to not execute until the given delay has passed. The first execution may be delayed using the optional fourth parameter startDelayed. This delay, if used, will be the same as the period.</p>
<p>Note that yielding for messages may extend this delay. However, if a message is received during the delay period., the procedure will still wait until the end of the delay period. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
    <tr><td class="paramname">period</td><td>&ndash; the schedule, in milliseconds </td></tr>
    <tr><td class="paramname">startWaiting</td><td>&ndash; for the first execution, start immediately (false), or delay its start for one period (true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3b61b260f5ddd9676f7a6899da40ad9e" title="endcond">add</a>, addDelayed, <a class="el" href="#aef8ccd8e7753e35a483dd8d9203ef8ca" title="Add a task that will be delayed until a set system clock time before its first invocation.">addWaitUntil</a> </dd></dl>

</div>
</div>
<a id="a2c4cd56685a46a66bb3b5a25c1ba8685" name="a2c4cd56685a46a66bb3b5a25c1ba8685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c4cd56685a46a66bb3b5a25c1ba8685">&#9670;&#160;</a></span>addAutoWaitMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::addAutoWaitMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a></td>          <td class="paramname"><span class="paramname"><em>taskId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*</td>          <td class="paramname"><span class="paramname"><em>fn&#160;</em></span>)(), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>startWaiting</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task that is waiting for a message or until a timeout occurs. </p>
<p>The task will be added, but will be set to be waiting for a message. If the message does not arrive before the timeout period (in milliseconds), then the routine will be activated. The routine may use <a class="el" href="class_task_manager.html" title="A cooperative multitasking manager.">TaskManager</a>:: () to determine whether it timed our or received a message. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
    <tr><td class="paramname">timeout</td><td>&ndash; the maximum time to wait (in ms) before timing out. </td></tr>
    <tr><td class="paramname">startWaiting</td><td>&ndash; tells whether the routine will start waiting for a message (true) or will execute immediately (false). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a51b5017ee459e0d54a0995c084bd273f" title="Add a task that is waiting for a message.">addWaitMessage</a> </dd></dl>

</div>
</div>
<a id="ad0d87e94ca41ece59e98adba02ba8103" name="ad0d87e94ca41ece59e98adba02ba8103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0d87e94ca41ece59e98adba02ba8103">&#9670;&#160;</a></span>addWaitDelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::addWaitDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a></td>          <td class="paramname"><span class="paramname"><em>taskId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*</td>          <td class="paramname"><span class="paramname"><em>fn&#160;</em></span>)(), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>msDelay</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task that will be delayed before its first invocation. </p>
<p>This task will execute once each cycle. Its first execution will be delayed for a set time. After this, unless the task forces itself into a different scheduling model (e.g., through yieldMessage), it will execute agaion at the next available opportunity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
    <tr><td class="paramname">msDelay</td><td>&ndash; the initial delay, in milliseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3b61b260f5ddd9676f7a6899da40ad9e" title="endcond">add</a>, <a class="el" href="#aef8ccd8e7753e35a483dd8d9203ef8ca" title="Add a task that will be delayed until a set system clock time before its first invocation.">addWaitUntil</a>, <a class="el" href="#a41d58e9b9e596b19264bb2cbf7c02878" title="Add a task that will automatically reschedule itself with a delay.">addAutoWaitDelay</a> </dd></dl>

</div>
</div>
<a id="a51b5017ee459e0d54a0995c084bd273f" name="a51b5017ee459e0d54a0995c084bd273f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b5017ee459e0d54a0995c084bd273f">&#9670;&#160;</a></span>addWaitMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::addWaitMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a></td>          <td class="paramname"><span class="paramname"><em>taskId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*</td>          <td class="paramname"><span class="paramname"><em>fn&#160;</em></span>)(), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task that is waiting for a message. </p>
<p>The task will be added, but will be waiting for a message. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
    <tr><td class="paramname">timeout</td><td>&ndash; the maximum time to wait (in ms) before timing out. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef8ccd8e7753e35a483dd8d9203ef8ca" name="aef8ccd8e7753e35a483dd8d9203ef8ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef8ccd8e7753e35a483dd8d9203ef8ca">&#9670;&#160;</a></span>addWaitUntil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::addWaitUntil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a></td>          <td class="paramname"><span class="paramname"><em>taskId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*</td>          <td class="paramname"><span class="paramname"><em>fn&#160;</em></span>)(), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>msWhen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task that will be delayed until a set system clock time before its first invocation. </p>
<p>This task will execute once each cycle. Its first execution will be delayed until a set system clock time. After this, unless the task forces itself into a different scheduling model (e.g., through yieldMessage), it will execute agaion at the next available opportunity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
    <tr><td class="paramname">msWhen</td><td>&ndash; the initial delay, in milliseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a3b61b260f5ddd9676f7a6899da40ad9e" title="endcond">add</a>, <a class="el" href="#ad0d87e94ca41ece59e98adba02ba8103" title="Add a task that will be delayed before its first invocation.">addWaitDelay</a>, <a class="el" href="#a41d58e9b9e596b19264bb2cbf7c02878" title="Add a task that will automatically reschedule itself with a delay.">addAutoWaitDelay</a> </dd></dl>

</div>
</div>
<a id="a9968aa8e895bfc0bbb0cd4e06ee14e6d" name="a9968aa8e895bfc0bbb0cd4e06ee14e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9968aa8e895bfc0bbb0cd4e06ee14e6d">&#9670;&#160;</a></span>findTaskById()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class___task_manager_task.html">_TaskManagerTask</a> * TaskManager::findTaskById </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a></td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a task by its ID. <br  />
 </p>
<p>This routine is for internal use only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID of the task </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="class___task_manager_task.html" title="Internal class to manage a single active task.">_TaskManagerTask</a> or NULL if not found </dd></dl>

</div>
</div>
<a id="ab7a70749690f57b64c4db036abf1fa9d" name="ab7a70749690f57b64c4db036abf1fa9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a70749690f57b64c4db036abf1fa9d">&#9670;&#160;</a></span>getMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * TaskManager::getMessage </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a task's message buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the actual message buffer. Use the contents of the buffer but do NOT modify it. If a task is killed, this pointer becomes invalid. </dd></dl>

</div>
</div>
<a id="a2512563ba937a3542cbe564830ce1ae0" name="a2512563ba937a3542cbe564830ce1ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2512563ba937a3542cbe564830ce1ae0">&#9670;&#160;</a></span>getMessageLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t TaskManager::getMessageLength </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of the message in the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the data block in the buffer. Note that if the content is a string, the size will be one greater than the string length to account for the trailing null. </dd></dl>

</div>
</div>
<a id="a1d7883ae6d432125c5bdf3e354a1696b" name="a1d7883ae6d432125c5bdf3e354a1696b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7883ae6d432125c5bdf3e354a1696b">&#9670;&#160;</a></span>getSource() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::getSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#a171e372bd267b282cf5a55106f4d18d2">tm_nodeId_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fromNodeId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fromTaskId</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get source node/task ID of last message. </p>
<p>Returns the nodeId and taskId of the node/task that last sent a message to the current task. If the current task has never received a message, returns [0 0]. If the last message was from "this" node, returns fromNodeId=0.</p>
<dl class="section note"><dt>Note</dt><dd>This routine is only available on ESP and RF24-enabled AVR environments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">fromNodeId</td><td>&ndash; the nodeId that sent the last message </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fromTaskId</td><td>&ndash; the taskId that sent the last message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f4e11619ef42339d1a20fa2d31b2b72" name="a0f4e11619ef42339d1a20fa2d31b2b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4e11619ef42339d1a20fa2d31b2b72">&#9670;&#160;</a></span>getSource() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::getSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fromTaskId</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get task ID of last message's sender. </p>
<p>Returns the taskId of the task that last sent a message to the current task. If the current task has never received a message, returns [0].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">fromTaskId</td><td>&ndash; the taskId that sent the last message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09bb6c7863e8d8f3744b8d6da95a56bf" name="a09bb6c7863e8d8f3744b8d6da95a56bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09bb6c7863e8d8f3744b8d6da95a56bf">&#9670;&#160;</a></span>internalSendMessage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::internalSendMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#a171e372bd267b282cf5a55106f4d18d2">tm_nodeId_t</a></td>          <td class="paramname"><span class="paramname"><em>fromNodeId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a></td>          <td class="paramname"><span class="paramname"><em>fromTaskId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a></td>          <td class="paramname"><span class="paramname"><em>taskId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>message</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a string message to a task on this system. Send a null-terminated (string) message to a task running on this system. This is the internal gateway used by both sendMessage("this node") and from the radio receiver module (messages from other nodes). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromNodeId</td><td>- the source node of the message. 0 means "this node". </td></tr>
    <tr><td class="paramname">fromTaskId</td><td>- the source task of the message. </td></tr>
    <tr><td class="paramname">taskId</td><td>- which task is to receive the message. </td></tr>
    <tr><td class="paramname">message</td><td>- a null-terminated string message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b702e8ce9d59865dcc6b58742b8254b" name="a1b702e8ce9d59865dcc6b58742b8254b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b702e8ce9d59865dcc6b58742b8254b">&#9670;&#160;</a></span>internalSendMessage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::internalSendMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#a171e372bd267b282cf5a55106f4d18d2">tm_nodeId_t</a></td>          <td class="paramname"><span class="paramname"><em>fromNodeId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a></td>          <td class="paramname"><span class="paramname"><em>fromTaskId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a></td>          <td class="paramname"><span class="paramname"><em>taskId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a binary message to a task on this system. Send a raw data (binary) message to a task running on this system. This is the internal gateway used by both sendMessage("this node") and from the radio receiver module (messages from other nodes). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromNodeId</td><td>- the source node of the message. 0 means "this node". </td></tr>
    <tr><td class="paramname">fromTaskId</td><td>- the source task of the message. </td></tr>
    <tr><td class="paramname">taskId</td><td>- which task is to receive the message. </td></tr>
    <tr><td class="paramname">buf</td><td>- the buffer with the message. </td></tr>
    <tr><td class="paramname">len</td><td>- the size of the buf (in bytes). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b88a62f061cbc8159a101844d8e5469" name="a2b88a62f061cbc8159a101844d8e5469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b88a62f061cbc8159a101844d8e5469">&#9670;&#160;</a></span>loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::loop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements a single pass for the system <a class="el" href="#a2b88a62f061cbc8159a101844d8e5469" title="Implements a single pass for the system loop() routine.">loop()</a> routine. </p>
<p>This performs a single iteration for the system <a class="el" href="#a2b88a62f061cbc8159a101844d8e5469" title="Implements a single pass for the system loop() routine.">loop()</a> routine. It finds the next runnable task and runs it. It processes any yield*() operations that the user routine may have executed.</p>
<p>This routine is for internal use only. </p>

</div>
</div>
<a id="a2d05cc9618f108007073ebcab05a61f7" name="a2d05cc9618f108007073ebcab05a61f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d05cc9618f108007073ebcab05a61f7">&#9670;&#160;</a></span>millis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long TaskManager::millis </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronized millisecond clock This is the virtual network clock value. It is the local clock, adjusted by the recorded offset between the local clock and the network clock. </p>
<dl class="section return"><dt>Returns</dt><dd>unsigned long int millisecond clock that is synchronized with the <a class="el" href="#a2d05cc9618f108007073ebcab05a61f7" title="Synchronized millisecond clock This is the virtual network clock value. It is the local clock,...">millis()</a>of a clock server. Note that if no clock server is defined, <a class="el" href="#a2d05cc9618f108007073ebcab05a61f7" title="Synchronized millisecond clock This is the virtual network clock value. It is the local clock,...">TaskManager::millis()</a> returns <a class="el" href="#a2d05cc9618f108007073ebcab05a61f7" title="Synchronized millisecond clock This is the virtual network clock value. It is the local clock,...">millis()</a>. </dd></dl>

</div>
</div>
<a id="a087a0368a1dc5670757f56000b906e22" name="a087a0368a1dc5670757f56000b906e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087a0368a1dc5670757f56000b906e22">&#9670;&#160;</a></span>myId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a> TaskManager::myId </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the task ID of the currently running task. </p>
<dl class="section return"><dt>Returns</dt><dd>The byte value that represents the current task's ID. </dd></dl>

</div>
</div>
<a id="ab797d73ccb1b1a13c797bd1262249dea" name="ab797d73ccb1b1a13c797bd1262249dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab797d73ccb1b1a13c797bd1262249dea">&#9670;&#160;</a></span>myNodeId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_task_manager_core_8h.html#a171e372bd267b282cf5a55106f4d18d2">tm_nodeId_t</a> TaskManager::myNodeId </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the node ID of this system. </p>
<dl class="section return"><dt>Returns</dt><dd>The byte value that is the current node's radio ID. If the radio has not been enabled, returns 0. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This routine is only available on ESP environments. </dd></dl>

</div>
</div>
<a id="a379de9acea847cd98206bb82376a65bc" name="a379de9acea847cd98206bb82376a65bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379de9acea847cd98206bb82376a65bc">&#9670;&#160;</a></span>radioBegin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::radioBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#a171e372bd267b282cf5a55106f4d18d2">tm_nodeId_t</a></td>          <td class="paramname"><span class="paramname"><em>nodeId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte</td>          <td class="paramname"><span class="paramname"><em>cePin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte</td>          <td class="paramname"><span class="paramname"><em>csPin</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the radio and start it receiving. </p>
<p>Create an RF24 radio instance and set our radio node ID.</p>
<p>Note that additional messages sent prior to the task executing will overwrite any prior messages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeId</td><td>&ndash; the node the message is sent to </td></tr>
    <tr><td class="paramname">cePin</td><td>&ndash; Chip Enable pin </td></tr>
    <tr><td class="paramname">csPin</td><td>&ndash; Chip Select pin </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This routine is only available on ESP and RF24-enabled AVR environments. </dd></dl>

</div>
</div>
<a id="a6ffabf2edb1ba7bc18785fc4217a3505" name="a6ffabf2edb1ba7bc18785fc4217a3505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffabf2edb1ba7bc18785fc4217a3505">&#9670;&#160;</a></span>resume() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TaskManager::resume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#a171e372bd267b282cf5a55106f4d18d2">tm_nodeId_t</a></td>          <td class="paramname"><span class="paramname"><em>nodeId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a></td>          <td class="paramname"><span class="paramname"><em>taskId</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume the given task on the given node. </p>
<p>Resumes a task on any node. If nodeID==0, it resumes a task on this node. If the node or task do not exist, nothing happens. If the task had not been suspended, nothing happens. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeId</td><td>The node containnig the task </td></tr>
    <tr><td class="paramname">taskId</td><td>The task to be resumed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Not implemented. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the task could be suspended, false otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This routine is only available on ESP and RF24-enabled AVR environments. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0b85b2e38baa808ad06b039adff9142c" title="Suspend the given task on this node.">suspend()</a> </dd></dl>

</div>
</div>
<a id="a1bf8c3e66349d6a15a3fe04f555c0480" name="a1bf8c3e66349d6a15a3fe04f555c0480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf8c3e66349d6a15a3fe04f555c0480">&#9670;&#160;</a></span>resume() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TaskManager::resume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a></td>          <td class="paramname"><span class="paramname"><em>taskId</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume the given task on this node. </p>
<p>Resumes a task. If the task do not exist, nothing happens. If the task had not been suspended, nothing happens. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>The task to be resumed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the task could be resumed, false otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Not implemented. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0b85b2e38baa808ad06b039adff9142c" title="Suspend the given task on this node.">suspend()</a> </dd></dl>

</div>
</div>
<a id="a4a15939190c8b370c1391963f5445d41" name="a4a15939190c8b370c1391963f5445d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a15939190c8b370c1391963f5445d41">&#9670;&#160;</a></span>resync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::resync </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>remoteMillis</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>resync Synchronize this node's <a class="el" href="#a2d05cc9618f108007073ebcab05a61f7" title="Synchronized millisecond clock This is the virtual network clock value. It is the local clock,...">millis()</a> timer to a remote time server node's <a class="el" href="#a2d05cc9618f108007073ebcab05a61f7" title="Synchronized millisecond clock This is the virtual network clock value. It is the local clock,...">millis()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remoteMillis</td><td>&ndash; the <a class="el" href="#a2d05cc9618f108007073ebcab05a61f7" title="Synchronized millisecond clock This is the virtual network clock value. It is the local clock,...">millis()</a> value from a master time server. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a966e7f218ea93bfb36020814ed489517" name="a966e7f218ea93bfb36020814ed489517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a966e7f218ea93bfb36020814ed489517">&#9670;&#160;</a></span>runtime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long TaskManager::runtime </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the time since the start of the run, in milliseconds. </p>
<p>Return the time (in ms) since the system has been restarted.</p>
<p>Note this time is in absolute ms, and is independent of the network synchronization clock (should the network synchronization clock be used). </p>

</div>
</div>
<a id="ae5ba60f8681afab4cc32d16759262760" name="ae5ba60f8681afab4cc32d16759262760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ba60f8681afab4cc32d16759262760">&#9670;&#160;</a></span>sendMessage() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TaskManager::sendMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#a171e372bd267b282cf5a55106f4d18d2">tm_nodeId_t</a></td>          <td class="paramname"><span class="paramname"><em>nodeId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a></td>          <td class="paramname"><span class="paramname"><em>taskId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>message</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a string message to a task on a different node. </p>
<p>Sends a message to a task. The message will go to only one task.</p>
<p>Note that once a task has been sent a message, it will not be waiting for other instances of the same siggnal number. Note that additional messages sent prior to the task executing will overwrite any prior messages. Messages that are too large are ignored. Remember to account for the trailing '<br  />
' when considering the string message size.</p>
<dl class="section note"><dt>Note</dt><dd>This routine is only available on ESP and RF24-enabled AVR environments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeId</td><td>&ndash; the node the message is sent to </td></tr>
    <tr><td class="paramname">taskId</td><td>&ndash; the ID number of the task </td></tr>
    <tr><td class="paramname">message</td><td>&ndash; the character string message. It is restricted in length to TASKMGR_MESSAGE_LENGTH-1 characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4f368a9141c55b085aefdc8833aeaeec" title="Exit from the task manager and do not restart this task until a message has been received or a stated...">yieldForMessage()</a> </dd></dl>

</div>
</div>
<a id="a8e041c5d9fad4453d24d18969123b07d" name="a8e041c5d9fad4453d24d18969123b07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e041c5d9fad4453d24d18969123b07d">&#9670;&#160;</a></span>sendMessage() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TaskManager::sendMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#a171e372bd267b282cf5a55106f4d18d2">tm_nodeId_t</a></td>          <td class="paramname"><span class="paramname"><em>nodeId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a></td>          <td class="paramname"><span class="paramname"><em>taskId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a binary message to a task on a different node. </p>
<p>Sends a message to a task. The message will go to only one task. Messages that are too large are ignored.</p>
<dl class="section note"><dt>Note</dt><dd>Additional messages sent prior to the task executing will overwrite any prior messages.</dd>
<dd>
This routine is only available on ESP and RF24-enabled AVR environments.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeId</td><td>&ndash; the node the message is sent to </td></tr>
    <tr><td class="paramname">taskId</td><td>&ndash; the ID number of the task </td></tr>
    <tr><td class="paramname">buf</td><td>&ndash; A pointer to the structure that is to be passed to the task </td></tr>
    <tr><td class="paramname">len</td><td>&ndash; The length of the buffer. Buffers can be at most TASKMGR_MESSAGE_LENGTH bytes long. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4f368a9141c55b085aefdc8833aeaeec" title="Exit from the task manager and do not restart this task until a message has been received or a stated...">yieldForMessage()</a> </dd></dl>

</div>
</div>
<a id="a79227d756bef8d23a2be42ff60f1c606" name="a79227d756bef8d23a2be42ff60f1c606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79227d756bef8d23a2be42ff60f1c606">&#9670;&#160;</a></span>sendMessage() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TaskManager::sendMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a></td>          <td class="paramname"><span class="paramname"><em>taskId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>message</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a string message to a task. </p>
<p>Sends a message to a task. The message will go to only one task.</p>
<p>Note that once a task has been sent a message, it will not be waiting for other instances of the same siggnal number. Note that additional messages sent prior to the task executing will overwrite any prior messages. Messages that are too large are ignored. Remember to account for the trailing '<br  />
' when considering the string message size.</p>
<dl class="section note"><dt>Note</dt><dd>In networked <a class="el" href="class_task_manager.html" title="A cooperative multitasking manager.">TaskManager</a> environments, this will send the message to a task on the current node.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>&ndash; the ID number of the task </td></tr>
    <tr><td class="paramname">message</td><td>&ndash; the character string message. It is restricted in length to TASKMGR_MESSAGE_LENGTH-1 characters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if message successfully sent, false otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4f368a9141c55b085aefdc8833aeaeec" title="Exit from the task manager and do not restart this task until a message has been received or a stated...">yieldForMessage()</a> </dd></dl>

</div>
</div>
<a id="a2668163bdcc5cd6057041cf766ed5e68" name="a2668163bdcc5cd6057041cf766ed5e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2668163bdcc5cd6057041cf766ed5e68">&#9670;&#160;</a></span>sendMessage() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TaskManager::sendMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a></td>          <td class="paramname"><span class="paramname"><em>taskId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buf</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a binary message to a task. </p>
<p>Sends a message to a task. The message will go to only one task. Messages that are too large are ignored.</p>
<dl class="section note"><dt>Note</dt><dd>Additional messages sent prior to the task executing will overwrite any prior messages.</dd>
<dd>
In networked <a class="el" href="class_task_manager.html" title="A cooperative multitasking manager.">TaskManager</a> environments, this will send the message to a task on the current node.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>&ndash; the ID number of the task </td></tr>
    <tr><td class="paramname">buf</td><td>&ndash; A pointer to the structure that is to be passed to the task </td></tr>
    <tr><td class="paramname">len</td><td>&ndash; The length of the buffer. Buffers can be at most TASKMGR_MESSAGE_LENGTH bytes long. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if message successfully sent, false otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a4f368a9141c55b085aefdc8833aeaeec" title="Exit from the task manager and do not restart this task until a message has been received or a stated...">yieldForMessage()</a> </dd></dl>

</div>
</div>
<a id="a9bb954eabd1933e6e846285210fff088" name="a9bb954eabd1933e6e846285210fff088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb954eabd1933e6e846285210fff088">&#9670;&#160;</a></span>suspend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TaskManager::suspend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#a171e372bd267b282cf5a55106f4d18d2">tm_nodeId_t</a></td>          <td class="paramname"><span class="paramname"><em>nodeId</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a></td>          <td class="paramname"><span class="paramname"><em>taskId</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend the given task on the given node. </p>
<p>Suspends a task on any node. If nodeID==0, it suspends a task on this node. If the node or task do not exist, nothing happens. If the task was already suspended, it remains suspended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeId</td><td>The node containing the task </td></tr>
    <tr><td class="paramname">taskId</td><td>The task to be suspended </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the task could be suspended, false otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Not implemented. </dd>
<dd>
This routine is only available on ESP and RF24-enabled AVR environments. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1bf8c3e66349d6a15a3fe04f555c0480" title="Resume the given task on this node.">resume()</a> </dd></dl>

</div>
</div>
<a id="a0b85b2e38baa808ad06b039adff9142c" name="a0b85b2e38baa808ad06b039adff9142c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b85b2e38baa808ad06b039adff9142c">&#9670;&#160;</a></span>suspend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TaskManager::suspend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_task_manager_core_8h.html#ac48b510cb8d291c64c8beec07747b15a">tm_taskId_t</a></td>          <td class="paramname"><span class="paramname"><em>taskId</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend the given task on this node. </p>
<p>The given task will be suspended until it is resumed. It will not be allowed to run, nor will it receive messages. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>The task to be suspended </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the task could be suspended, false otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd>receive </dd></dl>

</div>
</div>
<a id="ae7641b79a5efb0a5e640daa8f623fa5c" name="ae7641b79a5efb0a5e640daa8f623fa5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7641b79a5efb0a5e640daa8f623fa5c">&#9670;&#160;</a></span>timedOut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TaskManager::timedOut </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell if the current task has timed out while waiting for a message. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the task started due to timing out while waiting for a smessage; false otherwise. </dd></dl>

</div>
</div>
<a id="abc4f2e57cdc1fd1d3051b58dc816de98" name="abc4f2e57cdc1fd1d3051b58dc816de98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4f2e57cdc1fd1d3051b58dc816de98">&#9670;&#160;</a></span>yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::yield </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit from this task and return control to the task manager. </p>
<p>This exits from the current task, and returns control to the task manager. Functionally, it is similar to a return statement. The next time the task gains control, it will resume from the TOP of the routine. Note that if the task was an Auto task, it will be automatically rescheduled according to its Auto specifications. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a2123fa0af84c3a1373b9437e2157e872" title="Exit from the task manager and do not restart this task until after a specified period.">yieldDelay()</a>, <a class="el" href="#aa3f827ee35d80bc4faa2f7d438163e78" title="Exit from the task manager and do not restart this task until (after) a specified CPU clock time.">yieldUntil()</a>, yieldMessage(), <a class="el" href="#a41d58e9b9e596b19264bb2cbf7c02878" title="Add a task that will automatically reschedule itself with a delay.">addAutoWaitDelay()</a>, <a class="el" href="#a2c4cd56685a46a66bb3b5a25c1ba8685" title="Add a task that is waiting for a message or until a timeout occurs.">addAutoWaitMessage()</a> </dd></dl>

</div>
</div>
<a id="a2123fa0af84c3a1373b9437e2157e872" name="a2123fa0af84c3a1373b9437e2157e872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2123fa0af84c3a1373b9437e2157e872">&#9670;&#160;</a></span>yieldDelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::yieldDelay </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>ms</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit from the task manager and do not restart this task until after a specified period. </p>
<p>This exits from the current task and returns control to the task manager. This task will not be rescheduled until at least the stated number of milliseconds has passed. Note that yieldDelay <em>overrides</em> any of the Auto specifications. That is, the next rescheduling will occur <em>solely</em> after the stated time period, and will not be constrained by AutoWaitMessage, or a different AutoWaitDelay value. The Auto specification will be retained, and will be applied on future executions where <a class="el" href="#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager.">yield()</a> or a normal return are used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>&ndash; the delay in milliseconds. Note the next call may exceed this constraint depending on time taken by other tasks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager.">yield()</a>, <a class="el" href="#aa3f827ee35d80bc4faa2f7d438163e78" title="Exit from the task manager and do not restart this task until (after) a specified CPU clock time.">yieldUntil()</a>, yieldMessage(), <a class="el" href="#a41d58e9b9e596b19264bb2cbf7c02878" title="Add a task that will automatically reschedule itself with a delay.">addAutoWaitDelay()</a>, <a class="el" href="#a2c4cd56685a46a66bb3b5a25c1ba8685" title="Add a task that is waiting for a message or until a timeout occurs.">addAutoWaitMessage()</a> </dd></dl>

</div>
</div>
<a id="a4f368a9141c55b085aefdc8833aeaeec" name="a4f368a9141c55b085aefdc8833aeaeec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f368a9141c55b085aefdc8833aeaeec">&#9670;&#160;</a></span>yieldForMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::yieldForMessage </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit from the task manager and do not restart this task until a message has been received or a stated time period has passed. </p>
<p>This exits from the current task and returns control to the task manager. This task will not be rescheduled until a message has been received or a stated time period has passed (the timeout period). The TaskManager::timeOut() function will tell whether or not the timeout had been triggered.</p>
<dl class="section note"><dt>Note</dt><dd>The yieldForMessage call <em>overrides</em> any of the Auto specifications. That is, the next rescheduling will occur <em>solely</em> after the message has been received, and will not be constrained by AutoWaitDelay, or a different AutoWaitMessage value. The Auto specification will be retained, and will be applied on future executions where <a class="el" href="#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager.">yield()</a> or a normal return are used. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>&ndash; The timeout period, in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager.">yield()</a>, <a class="el" href="#a2123fa0af84c3a1373b9437e2157e872" title="Exit from the task manager and do not restart this task until after a specified period.">yieldDelay()</a>, <a class="el" href="#a41d58e9b9e596b19264bb2cbf7c02878" title="Add a task that will automatically reschedule itself with a delay.">addAutoWaitDelay()</a>, <a class="el" href="#a2c4cd56685a46a66bb3b5a25c1ba8685" title="Add a task that is waiting for a message or until a timeout occurs.">addAutoWaitMessage()</a>, timeOut() </dd></dl>

</div>
</div>
<a id="aa3f827ee35d80bc4faa2f7d438163e78" name="aa3f827ee35d80bc4faa2f7d438163e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f827ee35d80bc4faa2f7d438163e78">&#9670;&#160;</a></span>yieldUntil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::yieldUntil </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>when</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit from the task manager and do not restart this task until (after) a specified CPU clock time. </p>
<p>This exits from the current task and returns control to the task manager. This task will not be rescheduled until the CPU clock (<a class="el" href="#a2d05cc9618f108007073ebcab05a61f7" title="Synchronized millisecond clock This is the virtual network clock value. It is the local clock,...">millis()</a>) has exceeded the given time. Note that yieldUntil <em>overrides</em> any of the Auto specifications. That is, the next rescheduling will occur <em>solely</em> after the stated clock time has passed, and will not be constrained by AutoWaitMessage, or a different AutoWaitDelay value. The Auto specification will be retained, and will be applied on future executions where <a class="el" href="#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager.">yield()</a> or a normal return are used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">when</td><td>&ndash; The target CPU time. Note the next call may exceed this constraint depending on time taken by other tasks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager.">yield()</a>, <a class="el" href="#a2123fa0af84c3a1373b9437e2157e872" title="Exit from the task manager and do not restart this task until after a specified period.">yieldDelay()</a>, yieldMessage(), <a class="el" href="#a41d58e9b9e596b19264bb2cbf7c02878" title="Add a task that will automatically reschedule itself with a delay.">addAutoWaitDelay()</a>, <a class="el" href="#a2c4cd56685a46a66bb3b5a25c1ba8685" title="Add a task that is waiting for a message or until a timeout occurs.">addAutoWaitMessage()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ada5584ddd8b8f8e816153967619398e6" name="ada5584ddd8b8f8e816153967619398e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5584ddd8b8f8e816153967619398e6">&#9670;&#160;</a></span>m_TaskManagerMessageQueueSemaphore</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SemaphoreHandle_t TaskManager::m_TaskManagerMessageQueueSemaphore</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>cond IGNORE <br  />
 </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_task_manager_core_8h_source.html">TaskManagerCore.h</a></li>
<li>src/<b>radioDriverESP.cpp</b></li>
<li>src/<a class="el" href="_task_manager_8cpp.html">TaskManager.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
