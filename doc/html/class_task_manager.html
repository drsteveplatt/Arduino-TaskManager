<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>TaskManager: TaskManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TaskManager
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">A Task Manager for Arduinos</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_task_manager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TaskManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Manages a set of cooperative tasks.  
 <a href="class_task_manager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_task_manager_8h_source.html">TaskManager.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TaskManager:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_task_manager.png" usemap="#TaskManager_map" alt=""/>
  <map id="TaskManager_map" name="TaskManager_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a36210e786c8b94e0858c0df948521318"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a36210e786c8b94e0858c0df948521318">YieldTypes</a> { <br />
&#160;&#160;<a class="el" href="class_task_manager.html#a36210e786c8b94e0858c0df948521318aaa83b744b431450c40569fb787a9cc62">YtYield</a>, 
<a class="el" href="class_task_manager.html#a36210e786c8b94e0858c0df948521318a89e00019d0ccda9139d6599e4c9c83c5">YtYieldUntil</a>, 
<a class="el" href="class_task_manager.html#a36210e786c8b94e0858c0df948521318a5520a5cc62f59a79ac9df855695b2aee">YtYieldSignal</a>, 
<a class="el" href="class_task_manager.html#a36210e786c8b94e0858c0df948521318a8ba72bfec1db82ac312c46a4db617e0e">YtYieldSignalTimeout</a>, 
<br />
&#160;&#160;<a class="el" href="class_task_manager.html#a36210e786c8b94e0858c0df948521318a021639087baa77a364842df6e78d66fb">YtYieldMessage</a>, 
<a class="el" href="class_task_manager.html#a36210e786c8b94e0858c0df948521318ab3132706adb88e8931bcf3caf9c90182">YtYieldMessageTimeout</a>, 
<a class="el" href="class_task_manager.html#a36210e786c8b94e0858c0df948521318a7e2896dba2a019465d5f08dc5216d5eb">YtYieldSuspend</a>, 
<a class="el" href="class_task_manager.html#a36210e786c8b94e0858c0df948521318a5c95246258ae22a052d55e6effc4f8dc">YtYieldKill</a>
<br />
 }</td></tr>
<tr class="memdesc:a36210e786c8b94e0858c0df948521318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the different methods a process may yield control.  <a href="class_task_manager.html#a36210e786c8b94e0858c0df948521318">More...</a><br /></td></tr>
<tr class="separator:a36210e786c8b94e0858c0df948521318"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a491dc7a77a5381675f614a411755ef64"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a491dc7a77a5381675f614a411755ef64"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a491dc7a77a5381675f614a411755ef64">TaskManager</a> ()</td></tr>
<tr class="memdesc:a491dc7a77a5381675f614a411755ef64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, Creates an empty task. <br /></td></tr>
<tr class="separator:a491dc7a77a5381675f614a411755ef64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ecdd2b8a6b7545eae64da180ba80c53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a6ecdd2b8a6b7545eae64da180ba80c53">~TaskManager</a> ()</td></tr>
<tr class="memdesc:a6ecdd2b8a6b7545eae64da180ba80c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. Destroys the <a class="el" href="class_task_manager.html" title="Manages a set of cooperative tasks. ">TaskManager</a>.  <a href="#a6ecdd2b8a6b7545eae64da180ba80c53">More...</a><br /></td></tr>
<tr class="separator:a6ecdd2b8a6b7545eae64da180ba80c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece076dfbe6b0a93eedd7a292adeab65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#aece076dfbe6b0a93eedd7a292adeab65">add</a> (byte, void(*)())</td></tr>
<tr class="memdesc:aece076dfbe6b0a93eedd7a292adeab65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a simple task.  <a href="#aece076dfbe6b0a93eedd7a292adeab65">More...</a><br /></td></tr>
<tr class="separator:aece076dfbe6b0a93eedd7a292adeab65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13a030b77dc96dc4e8ca0e2c1f80c26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#aa13a030b77dc96dc4e8ca0e2c1f80c26">addWaitDelay</a> (byte, void(*)(), unsigned int)</td></tr>
<tr class="memdesc:aa13a030b77dc96dc4e8ca0e2c1f80c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task that will be delayed before its first invocation.  <a href="#aa13a030b77dc96dc4e8ca0e2c1f80c26">More...</a><br /></td></tr>
<tr class="separator:aa13a030b77dc96dc4e8ca0e2c1f80c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11b36a0c2f89d6bc537ff4376ca26f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#ad11b36a0c2f89d6bc537ff4376ca26f5">addWaitUntil</a> (byte, void(*)(), unsigned long)</td></tr>
<tr class="memdesc:ad11b36a0c2f89d6bc537ff4376ca26f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task that will be delayed until a set system clock time before its first invocation.  <a href="#ad11b36a0c2f89d6bc537ff4376ca26f5">More...</a><br /></td></tr>
<tr class="separator:ad11b36a0c2f89d6bc537ff4376ca26f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcf18d181fb18621dc5c833450dc4d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a0dcf18d181fb18621dc5c833450dc4d5">addAutoWaitDelay</a> (byte, void(*)(), unsigned int, bool startDelayed=false)</td></tr>
<tr class="memdesc:a0dcf18d181fb18621dc5c833450dc4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task that will automatically reschedule itself with a delay.  <a href="#a0dcf18d181fb18621dc5c833450dc4d5">More...</a><br /></td></tr>
<tr class="separator:a0dcf18d181fb18621dc5c833450dc4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540a21c6a6de30cf37421e37de5f0f79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a540a21c6a6de30cf37421e37de5f0f79">addWaitSignal</a> (byte, void(*)(), byte, unsigned int timeout=0)</td></tr>
<tr class="memdesc:a540a21c6a6de30cf37421e37de5f0f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task that will wait until a signal arrives or (optionally) a timeout occurs.  <a href="#a540a21c6a6de30cf37421e37de5f0f79">More...</a><br /></td></tr>
<tr class="separator:a540a21c6a6de30cf37421e37de5f0f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15b8303b799eb80f2a9a30d750fea0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#ad15b8303b799eb80f2a9a30d750fea0e">addAutoWaitSignal</a> (byte, void(*)(), byte, unsigned int timeout=0, bool startWaiting=true)</td></tr>
<tr class="memdesc:ad15b8303b799eb80f2a9a30d750fea0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task that waits until a signal arrives or (optionally) timeout occurs. The task automatically reschedules itself.  <a href="#ad15b8303b799eb80f2a9a30d750fea0e">More...</a><br /></td></tr>
<tr class="separator:ad15b8303b799eb80f2a9a30d750fea0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9ff04476305904cd68acfcd2c77735"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#acd9ff04476305904cd68acfcd2c77735">addWaitMessage</a> (byte, void(*)(), unsigned int timeout=0)</td></tr>
<tr class="memdesc:acd9ff04476305904cd68acfcd2c77735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task that is waiting for a message.  <a href="#acd9ff04476305904cd68acfcd2c77735">More...</a><br /></td></tr>
<tr class="separator:acd9ff04476305904cd68acfcd2c77735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9414298030ad56315deb42261209df79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a9414298030ad56315deb42261209df79">addAutoWaitMessage</a> (byte, void(*)(), unsigned int timeout=0, bool startWaiting=true)</td></tr>
<tr class="memdesc:a9414298030ad56315deb42261209df79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task that is waiting for a message or until a timeout occurs.  <a href="#a9414298030ad56315deb42261209df79">More...</a><br /></td></tr>
<tr class="separator:a9414298030ad56315deb42261209df79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4f2e57cdc1fd1d3051b58dc816de98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#abc4f2e57cdc1fd1d3051b58dc816de98">yield</a> ()</td></tr>
<tr class="memdesc:abc4f2e57cdc1fd1d3051b58dc816de98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit from this task and return control to the task manager.  <a href="#abc4f2e57cdc1fd1d3051b58dc816de98">More...</a><br /></td></tr>
<tr class="separator:abc4f2e57cdc1fd1d3051b58dc816de98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7604115fcf2aeca0b15f0aa92d6a048c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a7604115fcf2aeca0b15f0aa92d6a048c">yieldDelay</a> (int)</td></tr>
<tr class="memdesc:a7604115fcf2aeca0b15f0aa92d6a048c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit from the task manager and do not restart this task until after a specified period.  <a href="#a7604115fcf2aeca0b15f0aa92d6a048c">More...</a><br /></td></tr>
<tr class="separator:a7604115fcf2aeca0b15f0aa92d6a048c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f215104e1112fd506002d9d4894fce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#ac5f215104e1112fd506002d9d4894fce">yieldUntil</a> (unsigned long)</td></tr>
<tr class="memdesc:ac5f215104e1112fd506002d9d4894fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit from the task manager and do not restart this task until (after) a specified CPU clock time.  <a href="#ac5f215104e1112fd506002d9d4894fce">More...</a><br /></td></tr>
<tr class="separator:ac5f215104e1112fd506002d9d4894fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db602b48a774019ccb8320148e0f8e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a3db602b48a774019ccb8320148e0f8e1">yieldForSignal</a> (byte, unsigned int timeout=0)</td></tr>
<tr class="memdesc:a3db602b48a774019ccb8320148e0f8e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit from the task manager and do not restart this task until a signal has been received or a stated time period has passed.  <a href="#a3db602b48a774019ccb8320148e0f8e1">More...</a><br /></td></tr>
<tr class="separator:a3db602b48a774019ccb8320148e0f8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee8e9c6dcd5c990f8849293cf1d389a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a2ee8e9c6dcd5c990f8849293cf1d389a">yieldForMessage</a> (unsigned int timeout=0)</td></tr>
<tr class="memdesc:a2ee8e9c6dcd5c990f8849293cf1d389a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit from the task manager and do not restart this task until a message has been received or a stated time period has passed.  <a href="#a2ee8e9c6dcd5c990f8849293cf1d389a">More...</a><br /></td></tr>
<tr class="separator:a2ee8e9c6dcd5c990f8849293cf1d389a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7641b79a5efb0a5e640daa8f623fa5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7641b79a5efb0a5e640daa8f623fa5c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#ae7641b79a5efb0a5e640daa8f623fa5c">timedOut</a> ()</td></tr>
<tr class="memdesc:ae7641b79a5efb0a5e640daa8f623fa5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell if the current task has timed out. <br /></td></tr>
<tr class="separator:ae7641b79a5efb0a5e640daa8f623fa5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a70749690f57b64c4db036abf1fa9d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#ab7a70749690f57b64c4db036abf1fa9d">getMessage</a> ()</td></tr>
<tr class="memdesc:ab7a70749690f57b64c4db036abf1fa9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a task's message buffer.  <a href="#ab7a70749690f57b64c4db036abf1fa9d">More...</a><br /></td></tr>
<tr class="separator:ab7a70749690f57b64c4db036abf1fa9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc36e6ef3cf0dff1e201a2c6d411f97"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#adfc36e6ef3cf0dff1e201a2c6d411f97">myID</a> ()</td></tr>
<tr class="memdesc:adfc36e6ef3cf0dff1e201a2c6d411f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the task ID of the currently running task.  <a href="#adfc36e6ef3cf0dff1e201a2c6d411f97">More...</a><br /></td></tr>
<tr class="separator:adfc36e6ef3cf0dff1e201a2c6d411f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9432fd2a73e348ce00cf49c631ad66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#abf9432fd2a73e348ce00cf49c631ad66">sendSignal</a> (byte)</td></tr>
<tr class="memdesc:abf9432fd2a73e348ce00cf49c631ad66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a signal to a task.  <a href="#abf9432fd2a73e348ce00cf49c631ad66">More...</a><br /></td></tr>
<tr class="separator:abf9432fd2a73e348ce00cf49c631ad66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad987e8609d7925fc97d91ba49afa8ed5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#ad987e8609d7925fc97d91ba49afa8ed5">sendSignalAll</a> (byte)</td></tr>
<tr class="memdesc:ad987e8609d7925fc97d91ba49afa8ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a signal to all tasks that are waiting for this particular signal.  <a href="#ad987e8609d7925fc97d91ba49afa8ed5">More...</a><br /></td></tr>
<tr class="separator:ad987e8609d7925fc97d91ba49afa8ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee5e2f8a42db493117deddf0c5c33d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#afee5e2f8a42db493117deddf0c5c33d4">sendMessage</a> (byte, char *)</td></tr>
<tr class="memdesc:afee5e2f8a42db493117deddf0c5c33d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a string message to a task.  <a href="#afee5e2f8a42db493117deddf0c5c33d4">More...</a><br /></td></tr>
<tr class="separator:afee5e2f8a42db493117deddf0c5c33d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70daf90751f465012f4fe0e44132c0d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a70daf90751f465012f4fe0e44132c0d7">sendMessage</a> (byte, void *, int)</td></tr>
<tr class="memdesc:a70daf90751f465012f4fe0e44132c0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a binary message to a task.  <a href="#a70daf90751f465012f4fe0e44132c0d7">More...</a><br /></td></tr>
<tr class="separator:a70daf90751f465012f4fe0e44132c0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177bac2cbad40db6eac4877909a51f0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class___task_manager_task.html">_TaskManagerTask</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a177bac2cbad40db6eac4877909a51f0e">FindNextRunnable</a> ()</td></tr>
<tr class="memdesc:a177bac2cbad40db6eac4877909a51f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find tne next runnable task. Internal routine.  <a href="#a177bac2cbad40db6eac4877909a51f0e">More...</a><br /></td></tr>
<tr class="separator:a177bac2cbad40db6eac4877909a51f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126881c885723fe254e941391ad4472e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a126881c885723fe254e941391ad4472e"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a126881c885723fe254e941391ad4472e">runtime</a> () const </td></tr>
<tr class="memdesc:a126881c885723fe254e941391ad4472e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the time since the start of the run, in milliseconds. <br /></td></tr>
<tr class="separator:a126881c885723fe254e941391ad4472e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261cd53a22a9d260c64141b1c2d71364"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a261cd53a22a9d260c64141b1c2d71364">printTo</a> (Print &amp;p) const </td></tr>
<tr class="memdesc:a261cd53a22a9d260c64141b1c2d71364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support routine to allow the printing of the contents of a <a class="el" href="class_task_manager.html" title="Manages a set of cooperative tasks. ">TaskManager</a> object.  <a href="#a261cd53a22a9d260c64141b1c2d71364">More...</a><br /></td></tr>
<tr class="separator:a261cd53a22a9d260c64141b1c2d71364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b88a62f061cbc8159a101844d8e5469"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a2b88a62f061cbc8159a101844d8e5469">loop</a> ()</td></tr>
<tr class="memdesc:a2b88a62f061cbc8159a101844d8e5469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a single pass for the system <a class="el" href="class_task_manager.html#a2b88a62f061cbc8159a101844d8e5469" title="Implements a single pass for the system loop() routine. ">loop()</a> routine.  <a href="#a2b88a62f061cbc8159a101844d8e5469">More...</a><br /></td></tr>
<tr class="separator:a2b88a62f061cbc8159a101844d8e5469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a2a6da977b9d586fd16d71ff9108e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class___task_manager_task.html">_TaskManagerTask</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a99a2a6da977b9d586fd16d71ff9108e5">findTaskById</a> (byte id)</td></tr>
<tr class="memdesc:a99a2a6da977b9d586fd16d71ff9108e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a task by its ID.  <a href="#a99a2a6da977b9d586fd16d71ff9108e5">More...</a><br /></td></tr>
<tr class="separator:a99a2a6da977b9d586fd16d71ff9108e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a01f290a48b9f1f9ad4fdb08cffddaca5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01f290a48b9f1f9ad4fdb08cffddaca5"></a>
<a class="el" href="singletonring.html">ring</a>&lt; <a class="el" href="class___task_manager_task.html">_TaskManagerTask</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a01f290a48b9f1f9ad4fdb08cffddaca5">m_theTasks</a></td></tr>
<tr class="memdesc:a01f290a48b9f1f9ad4fdb08cffddaca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ring of all tasks. For internal use only. <br /></td></tr>
<tr class="separator:a01f290a48b9f1f9ad4fdb08cffddaca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d775065bfc22bbe1da009b1720398f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97d775065bfc22bbe1da009b1720398f"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a97d775065bfc22bbe1da009b1720398f">m_startTime</a></td></tr>
<tr class="memdesc:a97d775065bfc22bbe1da009b1720398f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start clock time. Used to calcualte runtime. For internal use only. <br /></td></tr>
<tr class="separator:a97d775065bfc22bbe1da009b1720398f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf36ceaa3877cf46ad4b2f4c6f8fdc7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bf36ceaa3877cf46ad4b2f4c6f8fdc7"></a>
jmp_buf&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html#a2bf36ceaa3877cf46ad4b2f4c6f8fdc7">taskJmpBuf</a></td></tr>
<tr class="memdesc:a2bf36ceaa3877cf46ad4b2f4c6f8fdc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jump buffer used by yield. For internal use only. <br /></td></tr>
<tr class="separator:a2bf36ceaa3877cf46ad4b2f4c6f8fdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Manages a set of cooperative tasks. </p>
<p>Manages a set of cooperative tasks. This includes round-robin scheduling, yielding, and inter-task messaging and signaling. It also replaces the <a class="el" href="class_task_manager.html#a2b88a62f061cbc8159a101844d8e5469" title="Implements a single pass for the system loop() routine. ">loop()</a> function in standard Arduino programs. Nominally, there is a single instance of <a class="el" href="class_task_manager.html" title="Manages a set of cooperative tasks. ">TaskManager</a> called TaskMgr. TaskMgr is used for all actual task control.</p>
<p>Each task has a taskID. By convention, user tasks' taskID values are in the range [0 127]. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a36210e786c8b94e0858c0df948521318"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_task_manager.html#a36210e786c8b94e0858c0df948521318">TaskManager::YieldTypes</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the different methods a process may yield control. </p>
<p>This is the return value passsed back by the different yield*() routines to the control <code><a class="el" href="class_task_manager.html#a2b88a62f061cbc8159a101844d8e5469" title="Implements a single pass for the system loop() routine. ">loop()</a></code>. It indicates which form of yield*() was called.</p>
<p>This is for internal use only. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a36210e786c8b94e0858c0df948521318aaa83b744b431450c40569fb787a9cc62"></a>YtYield&#160;</td><td class="fielddoc">
<p>Normal <a class="el" href="class_task_manager.html#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager. ">yield()</a> </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a36210e786c8b94e0858c0df948521318a89e00019d0ccda9139d6599e4c9c83c5"></a>YtYieldUntil&#160;</td><td class="fielddoc">
<p><a class="el" href="class_task_manager.html#ac5f215104e1112fd506002d9d4894fce" title="Exit from the task manager and do not restart this task until (after) a specified CPU clock time...">yieldUntil()</a> or <a class="el" href="class_task_manager.html#a7604115fcf2aeca0b15f0aa92d6a048c" title="Exit from the task manager and do not restart this task until after a specified period. ">yieldDelay()</a> </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a36210e786c8b94e0858c0df948521318a5520a5cc62f59a79ac9df855695b2aee"></a>YtYieldSignal&#160;</td><td class="fielddoc">
<p>yieldSignal() with no specified timeout </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a36210e786c8b94e0858c0df948521318a8ba72bfec1db82ac312c46a4db617e0e"></a>YtYieldSignalTimeout&#160;</td><td class="fielddoc">
<p>yieldSignal() with a specified timeout </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a36210e786c8b94e0858c0df948521318a021639087baa77a364842df6e78d66fb"></a>YtYieldMessage&#160;</td><td class="fielddoc">
<p>yieldMessage() </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a36210e786c8b94e0858c0df948521318ab3132706adb88e8931bcf3caf9c90182"></a>YtYieldMessageTimeout&#160;</td><td class="fielddoc">
<p>yieldMessage() with a specified timeout </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a36210e786c8b94e0858c0df948521318a7e2896dba2a019465d5f08dc5216d5eb"></a>YtYieldSuspend&#160;</td><td class="fielddoc">
<p>suspend() </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a36210e786c8b94e0858c0df948521318a5c95246258ae22a052d55e6effc4f8dc"></a>YtYieldKill&#160;</td><td class="fielddoc">
<p>killMe() </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6ecdd2b8a6b7545eae64da180ba80c53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TaskManager::~TaskManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. Destroys the <a class="el" href="class_task_manager.html" title="Manages a set of cooperative tasks. ">TaskManager</a>. </p>
<p>After calling this, any operations based on the object will fail. For normal purpoases, destroying the TaskMgr instance will have serious consequences for the standard <a class="el" href="class_task_manager.html#a2b88a62f061cbc8159a101844d8e5469" title="Implements a single pass for the system loop() routine. ">loop()</a> routine. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aece076dfbe6b0a93eedd7a292adeab65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::add </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a simple task. </p>
<p>The task will execute once each cycle through the task list. Unless the task itself forces itself into a different scheduling model (e.g., through YieldSignal), it will execute again at the next available opportunity </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#aa13a030b77dc96dc4e8ca0e2c1f80c26" title="Add a task that will be delayed before its first invocation. ">addWaitDelay</a>, <a class="el" href="class_task_manager.html#ad11b36a0c2f89d6bc537ff4376ca26f5" title="Add a task that will be delayed until a set system clock time before its first invocation. ">addWaitUntil</a>, <a class="el" href="class_task_manager.html#a0dcf18d181fb18621dc5c833450dc4d5" title="Add a task that will automatically reschedule itself with a delay. ">addAutoWaitDelay</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0dcf18d181fb18621dc5c833450dc4d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::addAutoWaitDelay </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startWaiting</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task that will automatically reschedule itself with a delay. </p>
<p>This task will execute once each cycle. The task will automatically reschedule itself to not execute until the given delay has passed. THe first execution may be delayed using the optional fourth parameter startDelayed. This delay, if used, will be the same as the period.</p>
<p>Note that yielding for messages or signals may extend this delay. However, if a signal/message is received during the delay period., the procedure will still wait until the end of the delay period. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
    <tr><td class="paramname">period</td><td>&ndash; the schedule, in milliseconds </td></tr>
    <tr><td class="paramname">startWaiting</td><td>&ndash; for the first execution, start immediately (false), or delay its start for one period (true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#aece076dfbe6b0a93eedd7a292adeab65" title="Add a simple task. ">add</a>, addDelayed, <a class="el" href="class_task_manager.html#ad11b36a0c2f89d6bc537ff4376ca26f5" title="Add a task that will be delayed until a set system clock time before its first invocation. ">addWaitUntil</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9414298030ad56315deb42261209df79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::addAutoWaitMessage </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startWaiting</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task that is waiting for a message or until a timeout occurs. </p>
<p>The task will be added, but will be set to be waiting for the listed signal. If the signal does not arrive before the timeout period (in milliseconds), then the routine will be activated. The routine may use TaskManager::timeout() to determine whether it timed our or received the signal. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
    <tr><td class="paramname">timeout</td><td>&ndash; the maximum time to wait (in ms) before timing out. </td></tr>
    <tr><td class="paramname">startWaiting</td><td>&ndash; tells whether the routine will start waiting for the signal (true) or will execute immediately (false). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#a9414298030ad56315deb42261209df79" title="Add a task that is waiting for a message or until a timeout occurs. ">addAutoWaitMessage</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad15b8303b799eb80f2a9a30d750fea0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::addAutoWaitSignal </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>sigNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startWaiting</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task that waits until a signal arrives or (optionally) timeout occurs. The task automatically reschedules itself. </p>
<p>The task will be added, but will be set to be waiting for the listed signal. If the task exits normally (normal return, fall out of the bottom, or <a class="el" href="class_task_manager.html#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager. ">yield()</a>), it will reschedule itself to wait for the same signal. If a timeout (&gt;0) is specified and the signal does not arrive before the timeout period (in milliseconds), then the routine will be activated. The routine may use TaskManager::timeout() to determine whether it timed our or received the signal. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
    <tr><td class="paramname">sigNum</td><td>&ndash; the signal the task will be waiting for </td></tr>
    <tr><td class="paramname">timeout</td><td>&ndash; the maximum time to wait (in ms) before timing out. </td></tr>
    <tr><td class="paramname">startWaiting</td><td>&ndash; tells whether the routine will start waiting for the signal (true) or will execute immediately (false). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#ad15b8303b799eb80f2a9a30d750fea0e" title="Add a task that waits until a signal arrives or (optionally) timeout occurs. The task automatically r...">addAutoWaitSignal</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa13a030b77dc96dc4e8ca0e2c1f80c26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::addWaitDelay </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>msDelay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task that will be delayed before its first invocation. </p>
<p>This task will execute once each cycle. Its first execution will be delayed for a set time. After this, unless the task forces itself into a different scheduling model (e.g., through yieldSignal), it will execute agaion at the next available opportunity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
    <tr><td class="paramname">msDelay</td><td>&ndash; the initial delay, in milliseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#aece076dfbe6b0a93eedd7a292adeab65" title="Add a simple task. ">add</a>, <a class="el" href="class_task_manager.html#ad11b36a0c2f89d6bc537ff4376ca26f5" title="Add a task that will be delayed until a set system clock time before its first invocation. ">addWaitUntil</a>, <a class="el" href="class_task_manager.html#a0dcf18d181fb18621dc5c833450dc4d5" title="Add a task that will automatically reschedule itself with a delay. ">addAutoWaitDelay</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acd9ff04476305904cd68acfcd2c77735"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::addWaitMessage </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task that is waiting for a message. </p>
<p>The task will be added, but will be waiting for a message. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
    <tr><td class="paramname">timeout</td><td>&ndash; the maximum time to wait (in ms) before timing out. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a540a21c6a6de30cf37421e37de5f0f79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::addWaitSignal </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>sigNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task that will wait until a signal arrives or (optionally) a timeout occurs. </p>
<p>The task will be added, but will be set to be waiting for the listed signal. If a nonzero timeout is specified and ifthe signal does not arrive before the timeout period (in milliseconds), then the routine will be activated. The routine may use TaskManager::timeout() to determine whether it timed our or received the signal.</p>
<p>Note that calling <a class="el" href="class_task_manager.html#a540a21c6a6de30cf37421e37de5f0f79" title="Add a task that will wait until a signal arrives or (optionally) a timeout occurs. ">addWaitSignal()</a> with no timeout or startWaiting parmeter, the task will start in a wait state with no timeout. To start the task in a non-wait-state (active) with no timeout, the routine must be called as addWaitSignal(id, fn, 0, false). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
    <tr><td class="paramname">sigNum</td><td>&ndash; the signal the task will be waiting for </td></tr>
    <tr><td class="paramname">timeout</td><td>&ndash; the maximum time to wait (in ms) before timing out. The default is zero (no timeout). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#ad15b8303b799eb80f2a9a30d750fea0e" title="Add a task that waits until a signal arrives or (optionally) timeout occurs. The task automatically r...">addAutoWaitSignal</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad11b36a0c2f89d6bc537ff4376ca26f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::addWaitUntil </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>msWhen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task that will be delayed until a set system clock time before its first invocation. </p>
<p>This task will execute once each cycle. Its first execution will be delayed until a set system clock time. After this, unless the task forces itself into a different scheduling model (e.g., through yieldSignal), it will execute agaion at the next available opportunity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
    <tr><td class="paramname">msWhen</td><td>&ndash; the initial delay, in milliseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#aece076dfbe6b0a93eedd7a292adeab65" title="Add a simple task. ">add</a>, addDelayed, addAutoReachedule </dd></dl>

</div>
</div>
<a class="anchor" id="a177bac2cbad40db6eac4877909a51f0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class___task_manager_task.html">_TaskManagerTask</a> * TaskManager::FindNextRunnable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find tne next runnable task. Internal routine. </p>
<p>Finds the next runnaable task on the task ring. This routine assumes that the task ring is on the most-recently-run task. It moves the task ring to the next task that is ready to run. Since there is a null task and it is always runnable, <a class="el" href="class_task_manager.html#a177bac2cbad40db6eac4877909a51f0e" title="Find tne next runnable task. Internal routine. ">FindNextRunnable()</a> is guaranteed to find a runnable task. For internal use only. </p>

</div>
</div>
<a class="anchor" id="a99a2a6da977b9d586fd16d71ff9108e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class___task_manager_task.html">_TaskManagerTask</a> * TaskManager::findTaskById </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a task by its ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID of the task </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="class___task_manager_task.html" title="Internal class to manage a single active task. ">_TaskManagerTask</a> or NULL if not found </dd></dl>

</div>
</div>
<a class="anchor" id="ab7a70749690f57b64c4db036abf1fa9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * TaskManager::getMessage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a task's message buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the actual message buffer. Use the contents of the buffer but do NOT modify it. If a task is killed, this pointer becomes invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b88a62f061cbc8159a101844d8e5469"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::loop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements a single pass for the system <a class="el" href="class_task_manager.html#a2b88a62f061cbc8159a101844d8e5469" title="Implements a single pass for the system loop() routine. ">loop()</a> routine. </p>
<p>This performs a single iteration for the system <a class="el" href="class_task_manager.html#a2b88a62f061cbc8159a101844d8e5469" title="Implements a single pass for the system loop() routine. ">loop()</a> routine. It finds the next runnable task and runs it. It processes any yield*() operations that the user routine may have executed.</p>
<p>This routine is for internal use only. </p>

</div>
</div>
<a class="anchor" id="adfc36e6ef3cf0dff1e201a2c6d411f97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte TaskManager::myID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the task ID of the currently running task. </p>
<dl class="section return"><dt>Returns</dt><dd>The byte value that represents the current task's ID. </dd></dl>

</div>
</div>
<a class="anchor" id="a261cd53a22a9d260c64141b1c2d71364"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t TaskManager::printTo </td>
          <td>(</td>
          <td class="paramtype">Print &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Support routine to allow the printing of the contents of a <a class="el" href="class_task_manager.html" title="Manages a set of cooperative tasks. ">TaskManager</a> object. </p>
<p>This prints a <a class="el" href="class_task_manager.html" title="Manages a set of cooperative tasks. ">TaskManager</a> object. It should only be used for debugging purposes. </p>

</div>
</div>
<a class="anchor" id="afee5e2f8a42db493117deddf0c5c33d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::sendMessage </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a string message to a task. </p>
<p>Sends a message to a task. The message will go to only one task.</p>
<p>Note that once a task has been sent a message, it will not be waiting for other instances of the same siggnal number. Note that additional messages sent prior to the task executing will overwrite any prior messages. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>&ndash; the ID number of the task </td></tr>
    <tr><td class="paramname">message</td><td>&ndash; the character string message. It is restricted in length to 24 characters. Longer messages will be ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#a2ee8e9c6dcd5c990f8849293cf1d389a" title="Exit from the task manager and do not restart this task until a message has been received or a stated...">yieldForMessage()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a70daf90751f465012f4fe0e44132c0d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::sendMessage </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a binary message to a task. </p>
<p>Sends a message to a task. The message will go to only one task. Note that once a task has been sent a message, it will not be waiting for other instances of the same siggnal number.</p>
<p>Note that additional messages sent prior to the task executing will overwrite any prior messages. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>&ndash; the ID number of the task </td></tr>
    <tr><td class="paramname">buf</td><td>&ndash; A pointer to the structure that is to be passed to the task </td></tr>
    <tr><td class="paramname">len</td><td>&ndash; The length of the buffer. Buffers over 24 bytes long will be ignored &ndash; no message will be sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#a2ee8e9c6dcd5c990f8849293cf1d389a" title="Exit from the task manager and do not restart this task until a message has been received or a stated...">yieldForMessage()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abf9432fd2a73e348ce00cf49c631ad66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::sendSignal </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>sigNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a signal to a task. </p>
<p>Sends a signal to a task. The signal will go to only one task. If there are several tasks waiting on the signal, it will go to the first task found that is waiting for this particular signal. Note that once a task is signalled, it will not be waiting for other instances of the same siggnal number. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sigNum</td><td>&ndash; the value of the signal to be sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#a3db602b48a774019ccb8320148e0f8e1" title="Exit from the task manager and do not restart this task until a signal has been received or a stated ...">yieldForSignal()</a>, <a class="el" href="class_task_manager.html#ad987e8609d7925fc97d91ba49afa8ed5" title="Send a signal to all tasks that are waiting for this particular signal. ">sendSignalAll()</a>, <a class="el" href="class_task_manager.html#a540a21c6a6de30cf37421e37de5f0f79" title="Add a task that will wait until a signal arrives or (optionally) a timeout occurs. ">addWaitSignal</a>, <a class="el" href="class_task_manager.html#ad15b8303b799eb80f2a9a30d750fea0e" title="Add a task that waits until a signal arrives or (optionally) timeout occurs. The task automatically r...">addAutoWaitSignal()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad987e8609d7925fc97d91ba49afa8ed5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::sendSignalAll </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>sigNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a signal to all tasks that are waiting for this particular signal. </p>
<p>Signals all tasks that are waiting for signal <em>sigNum</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sigNum</td><td>&ndash; the signal number to be sent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#abf9432fd2a73e348ce00cf49c631ad66" title="Sends a signal to a task. ">sendSignal()</a>, yieldForSiganl(), <a class="el" href="class_task_manager.html#a540a21c6a6de30cf37421e37de5f0f79" title="Add a task that will wait until a signal arrives or (optionally) a timeout occurs. ">addWaitSignal()</a>, <a class="el" href="class_task_manager.html#ad15b8303b799eb80f2a9a30d750fea0e" title="Add a task that waits until a signal arrives or (optionally) timeout occurs. The task automatically r...">addAutoWaitSignal()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abc4f2e57cdc1fd1d3051b58dc816de98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::yield </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit from this task and return control to the task manager. </p>
<p>This exits from the current task, and returns control to the task manager. Functionally, it is similar to a return statement. The next time the task gains control, it will resume from the TOP of the routine. Note that if the task was an Auto task, it will be automatically rescheduled according to its Auto specifications. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#a7604115fcf2aeca0b15f0aa92d6a048c" title="Exit from the task manager and do not restart this task until after a specified period. ">yieldDelay()</a>, <a class="el" href="class_task_manager.html#ac5f215104e1112fd506002d9d4894fce" title="Exit from the task manager and do not restart this task until (after) a specified CPU clock time...">yieldUntil()</a>, yieldSignal(), yieldMessage(), <a class="el" href="class_task_manager.html#a0dcf18d181fb18621dc5c833450dc4d5" title="Add a task that will automatically reschedule itself with a delay. ">addAutoWaitDelay()</a>, <a class="el" href="class_task_manager.html#ad15b8303b799eb80f2a9a30d750fea0e" title="Add a task that waits until a signal arrives or (optionally) timeout occurs. The task automatically r...">addAutoWaitSignal()</a>, <a class="el" href="class_task_manager.html#a9414298030ad56315deb42261209df79" title="Add a task that is waiting for a message or until a timeout occurs. ">addAutoWaitMessage()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7604115fcf2aeca0b15f0aa92d6a048c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::yieldDelay </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit from the task manager and do not restart this task until after a specified period. </p>
<p>This exits from the current task and returns control to the task manager. This task will not be rescheduled until at least the stated number of milliseconds has passed. Note that yieldDelay <em>overrides</em> any of the Auto specifications. That is, the next rescheduling will occur <em>solely</em> after the stated time period, and will not be constrained by AutoWaitSignal, AutoWaitMessage, or a different AutoWaitDelay value. The Auto specification will be retained, and will be applied on future executions where <a class="el" href="class_task_manager.html#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager. ">yield()</a> or a normal return are used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>&ndash; the delay in milliseconds. Note the next call may exceed this constraint depending on time taken by other tasks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager. ">yield()</a>, <a class="el" href="class_task_manager.html#ac5f215104e1112fd506002d9d4894fce" title="Exit from the task manager and do not restart this task until (after) a specified CPU clock time...">yieldUntil()</a>, yieldSignal(), yieldMessage(), <a class="el" href="class_task_manager.html#a0dcf18d181fb18621dc5c833450dc4d5" title="Add a task that will automatically reschedule itself with a delay. ">addAutoWaitDelay()</a>, <a class="el" href="class_task_manager.html#ad15b8303b799eb80f2a9a30d750fea0e" title="Add a task that waits until a signal arrives or (optionally) timeout occurs. The task automatically r...">addAutoWaitSignal()</a>, <a class="el" href="class_task_manager.html#a9414298030ad56315deb42261209df79" title="Add a task that is waiting for a message or until a timeout occurs. ">addAutoWaitMessage()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2ee8e9c6dcd5c990f8849293cf1d389a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::yieldForMessage </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit from the task manager and do not restart this task until a message has been received or a stated time period has passed. </p>
<p>This exits from the current task and returns control to the task manager. This task will not be rescheduled until a message has been received or a stated time period has passed (the timeout period). The TaskManager::timeOut() function will tell whether or not the timeout had been triggered.</p>
<p>Note that yieldForMessage <em>overrides</em> any of the Auto specifications. That is, the next rescheduling will occur <em>solely</em> after the signal has been received, and will not be constrained by AutoWaitDelay, AutoWaitSignal, or a different AutoWaitMessage value. The Auto specification will be retained, and will be applied on future executions where <a class="el" href="class_task_manager.html#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager. ">yield()</a> or a normal return are used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>&ndash; The timeout period, in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager. ">yield()</a>, <a class="el" href="class_task_manager.html#a7604115fcf2aeca0b15f0aa92d6a048c" title="Exit from the task manager and do not restart this task until after a specified period. ">yieldDelay()</a>, <a class="el" href="class_task_manager.html#a3db602b48a774019ccb8320148e0f8e1" title="Exit from the task manager and do not restart this task until a signal has been received or a stated ...">yieldForSignal()</a>, <a class="el" href="class_task_manager.html#a0dcf18d181fb18621dc5c833450dc4d5" title="Add a task that will automatically reschedule itself with a delay. ">addAutoWaitDelay()</a>, <a class="el" href="class_task_manager.html#ad15b8303b799eb80f2a9a30d750fea0e" title="Add a task that waits until a signal arrives or (optionally) timeout occurs. The task automatically r...">addAutoWaitSignal()</a>, <a class="el" href="class_task_manager.html#a9414298030ad56315deb42261209df79" title="Add a task that is waiting for a message or until a timeout occurs. ">addAutoWaitMessage()</a>, timeOut() </dd></dl>

</div>
</div>
<a class="anchor" id="a3db602b48a774019ccb8320148e0f8e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::yieldForSignal </td>
          <td>(</td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>sigNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit from the task manager and do not restart this task until a signal has been received or a stated time period has passed. </p>
<p>This exits from the current task and returns control to the task manager. This task will not be rescheduled until the given signal has been received or a stated time period has passed (the timeout period). The TaskManager::timeOut() function will tell whether or not the timeout had been triggered.</p>
<p>Note that yieldForSignal <em>overrides</em> any of the Auto specifications. That is, the next rescheduling will occur <em>solely</em> after the signal has been received, and will not be constrained by AutoWaitDelay, AutoWaitMessage, or a different AutoWaitSignal value. The Auto specification will be retained, and will be applied on future executions where <a class="el" href="class_task_manager.html#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager. ">yield()</a> or a normal return are used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sigNum</td><td>&ndash; the value of the signal the task will wait for. </td></tr>
    <tr><td class="paramname">timeout</td><td>&ndash; The timeout period, in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager. ">yield()</a>, <a class="el" href="class_task_manager.html#a7604115fcf2aeca0b15f0aa92d6a048c" title="Exit from the task manager and do not restart this task until after a specified period. ">yieldDelay()</a>, <a class="el" href="class_task_manager.html#a2ee8e9c6dcd5c990f8849293cf1d389a" title="Exit from the task manager and do not restart this task until a message has been received or a stated...">yieldForMessage()</a>, <a class="el" href="class_task_manager.html#a0dcf18d181fb18621dc5c833450dc4d5" title="Add a task that will automatically reschedule itself with a delay. ">addAutoWaitDelay()</a>, <a class="el" href="class_task_manager.html#ad15b8303b799eb80f2a9a30d750fea0e" title="Add a task that waits until a signal arrives or (optionally) timeout occurs. The task automatically r...">addAutoWaitSignal()</a>, <a class="el" href="class_task_manager.html#a9414298030ad56315deb42261209df79" title="Add a task that is waiting for a message or until a timeout occurs. ">addAutoWaitMessage()</a>, timeOut() </dd></dl>

</div>
</div>
<a class="anchor" id="ac5f215104e1112fd506002d9d4894fce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::yieldUntil </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>when</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit from the task manager and do not restart this task until (after) a specified CPU clock time. </p>
<p>This exits from the current task and returns control to the task manager. This task will not be rescheduled until the CPU clock (millis()) has exceeded the given time. Note that yieldUntil <em>overrides</em> any of the Auto specifications. That is, the next rescheduling will occur <em>solely</em> after the stated clock time has passed, and will not be constrained by AutoWaitSignal, AutoWaitMessage, or a different AutoWaitDelay value. The Auto specification will be retained, and will be applied on future executions where <a class="el" href="class_task_manager.html#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager. ">yield()</a> or a normal return are used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">when</td><td>&ndash; The target CPU time. Note the next call may exceed this constraint depending on time taken by other tasks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task_manager.html#abc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager. ">yield()</a>, <a class="el" href="class_task_manager.html#a7604115fcf2aeca0b15f0aa92d6a048c" title="Exit from the task manager and do not restart this task until after a specified period. ">yieldDelay()</a>, yieldSignal(), yieldMessage(), <a class="el" href="class_task_manager.html#a0dcf18d181fb18621dc5c833450dc4d5" title="Add a task that will automatically reschedule itself with a delay. ">addAutoWaitDelay()</a>, <a class="el" href="class_task_manager.html#ad15b8303b799eb80f2a9a30d750fea0e" title="Add a task that waits until a signal arrives or (optionally) timeout occurs. The task automatically r...">addAutoWaitSignal()</a>, <a class="el" href="class_task_manager.html#a9414298030ad56315deb42261209df79" title="Add a task that is waiting for a message or until a timeout occurs. ">addAutoWaitMessage()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_task_manager_8h_source.html">TaskManager.h</a></li>
<li><a class="el" href="_task_manager_8cpp.html">TaskManager.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 18 2015 14:26:20 for TaskManager by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
