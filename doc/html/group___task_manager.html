<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TaskManager: TaskManager</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">TaskManager<span id="projectnumber">&#160;2.0</span>
   </div>
   <div id="projectbrief">A Task Manager for Arduinos</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle"><div class="title">TaskManager</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__fixed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fixed.html">Predefined TaskIDs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__constructor"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constructor.html">Constructor and Destructor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__add"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__add.html">Adding Tasks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__yield"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__yield.html">Yield Methods</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__send"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__send.html">Sending Messages</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__receive"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__receive.html">Receiving Messages</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__task"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__task.html">Task Management</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__internal"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__internal.html">Internal components</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__radio"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__radio.html">Network/mesh functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__misc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__misc.html">Miscellaneous and Informational Routines</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task_manager.html">TaskManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cooperative multitasking manager.  <a href="class_task_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga491dc7a77a5381675f614a411755ef64"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___task_manager.html#ga491dc7a77a5381675f614a411755ef64">TaskManager::TaskManager</a> ()</td></tr>
<tr class="memdesc:ga491dc7a77a5381675f614a411755ef64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, Creates an empty task.  <a href="group___task_manager.html#ga491dc7a77a5381675f614a411755ef64">More...</a><br /></td></tr>
<tr class="separator:ga491dc7a77a5381675f614a411755ef64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ecdd2b8a6b7545eae64da180ba80c53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___task_manager.html#ga6ecdd2b8a6b7545eae64da180ba80c53">TaskManager::~TaskManager</a> ()</td></tr>
<tr class="memdesc:ga6ecdd2b8a6b7545eae64da180ba80c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. Destroys the <a class="el" href="class_task_manager.html" title="A cooperative multitasking manager.">TaskManager</a>.  <a href="group___task_manager.html#ga6ecdd2b8a6b7545eae64da180ba80c53">More...</a><br /></td></tr>
<tr class="separator:ga6ecdd2b8a6b7545eae64da180ba80c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b61b260f5ddd9676f7a6899da40ad9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___task_manager.html#ga3b61b260f5ddd9676f7a6899da40ad9e">TaskManager::add</a> (tm_taskId_t taskId, void(*fn)())</td></tr>
<tr class="memdesc:ga3b61b260f5ddd9676f7a6899da40ad9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a simple task.  <a href="group___task_manager.html#ga3b61b260f5ddd9676f7a6899da40ad9e">More...</a><br /></td></tr>
<tr class="separator:ga3b61b260f5ddd9676f7a6899da40ad9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0d87e94ca41ece59e98adba02ba8103"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___task_manager.html#gad0d87e94ca41ece59e98adba02ba8103">TaskManager::addWaitDelay</a> (tm_taskId_t taskId, void(*fn)(), unsigned long msDelay)</td></tr>
<tr class="memdesc:gad0d87e94ca41ece59e98adba02ba8103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task that will be delayed before its first invocation.  <a href="group___task_manager.html#gad0d87e94ca41ece59e98adba02ba8103">More...</a><br /></td></tr>
<tr class="separator:gad0d87e94ca41ece59e98adba02ba8103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef8ccd8e7753e35a483dd8d9203ef8ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___task_manager.html#gaef8ccd8e7753e35a483dd8d9203ef8ca">TaskManager::addWaitUntil</a> (tm_taskId_t taskId, void(*fn)(), unsigned long msWhen)</td></tr>
<tr class="memdesc:gaef8ccd8e7753e35a483dd8d9203ef8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task that will be delayed until a set system clock time before its first invocation.  <a href="group___task_manager.html#gaef8ccd8e7753e35a483dd8d9203ef8ca">More...</a><br /></td></tr>
<tr class="separator:gaef8ccd8e7753e35a483dd8d9203ef8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51b5017ee459e0d54a0995c084bd273f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___task_manager.html#ga51b5017ee459e0d54a0995c084bd273f">TaskManager::addWaitMessage</a> (tm_taskId_t taskId, void(*fn)(), unsigned long timeout=0)</td></tr>
<tr class="memdesc:ga51b5017ee459e0d54a0995c084bd273f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task that is waiting for a message.  <a href="group___task_manager.html#ga51b5017ee459e0d54a0995c084bd273f">More...</a><br /></td></tr>
<tr class="separator:ga51b5017ee459e0d54a0995c084bd273f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41d58e9b9e596b19264bb2cbf7c02878"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___task_manager.html#ga41d58e9b9e596b19264bb2cbf7c02878">TaskManager::addAutoWaitDelay</a> (tm_taskId_t taskId, void(*fn)(), unsigned long period, bool startDelayed=false)</td></tr>
<tr class="memdesc:ga41d58e9b9e596b19264bb2cbf7c02878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task that will automatically reschedule itself with a delay.  <a href="group___task_manager.html#ga41d58e9b9e596b19264bb2cbf7c02878">More...</a><br /></td></tr>
<tr class="separator:ga41d58e9b9e596b19264bb2cbf7c02878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c4cd56685a46a66bb3b5a25c1ba8685"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___task_manager.html#ga2c4cd56685a46a66bb3b5a25c1ba8685">TaskManager::addAutoWaitMessage</a> (tm_taskId_t taskId, void(*fn)(), unsigned long timeout=0, bool startWaiting=true)</td></tr>
<tr class="memdesc:ga2c4cd56685a46a66bb3b5a25c1ba8685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a task that is waiting for a message or until a timeout occurs.  <a href="group___task_manager.html#ga2c4cd56685a46a66bb3b5a25c1ba8685">More...</a><br /></td></tr>
<tr class="separator:ga2c4cd56685a46a66bb3b5a25c1ba8685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc4f2e57cdc1fd1d3051b58dc816de98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___task_manager.html#gabc4f2e57cdc1fd1d3051b58dc816de98">TaskManager::yield</a> ()</td></tr>
<tr class="memdesc:gabc4f2e57cdc1fd1d3051b58dc816de98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit from this task and return control to the task manager.  <a href="group___task_manager.html#gabc4f2e57cdc1fd1d3051b58dc816de98">More...</a><br /></td></tr>
<tr class="separator:gabc4f2e57cdc1fd1d3051b58dc816de98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2123fa0af84c3a1373b9437e2157e872"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___task_manager.html#ga2123fa0af84c3a1373b9437e2157e872">TaskManager::yieldDelay</a> (unsigned long ms)</td></tr>
<tr class="memdesc:ga2123fa0af84c3a1373b9437e2157e872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit from the task manager and do not restart this task until after a specified period.  <a href="group___task_manager.html#ga2123fa0af84c3a1373b9437e2157e872">More...</a><br /></td></tr>
<tr class="separator:ga2123fa0af84c3a1373b9437e2157e872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3f827ee35d80bc4faa2f7d438163e78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___task_manager.html#gaa3f827ee35d80bc4faa2f7d438163e78">TaskManager::yieldUntil</a> (unsigned long when)</td></tr>
<tr class="memdesc:gaa3f827ee35d80bc4faa2f7d438163e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit from the task manager and do not restart this task until (after) a specified CPU clock time.  <a href="group___task_manager.html#gaa3f827ee35d80bc4faa2f7d438163e78">More...</a><br /></td></tr>
<tr class="separator:gaa3f827ee35d80bc4faa2f7d438163e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f368a9141c55b085aefdc8833aeaeec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___task_manager.html#ga4f368a9141c55b085aefdc8833aeaeec">TaskManager::yieldForMessage</a> (unsigned long timeout=0)</td></tr>
<tr class="memdesc:ga4f368a9141c55b085aefdc8833aeaeec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit from the task manager and do not restart this task until a message has been received or a stated time period has passed.  <a href="group___task_manager.html#ga4f368a9141c55b085aefdc8833aeaeec">More...</a><br /></td></tr>
<tr class="separator:ga4f368a9141c55b085aefdc8833aeaeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b85b2e38baa808ad06b039adff9142c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___task_manager.html#ga0b85b2e38baa808ad06b039adff9142c">TaskManager::suspend</a> (tm_taskId_t taskId)</td></tr>
<tr class="memdesc:ga0b85b2e38baa808ad06b039adff9142c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend the given task on this node.  <a href="group___task_manager.html#ga0b85b2e38baa808ad06b039adff9142c">More...</a><br /></td></tr>
<tr class="separator:ga0b85b2e38baa808ad06b039adff9142c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bf8c3e66349d6a15a3fe04f555c0480"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___task_manager.html#ga1bf8c3e66349d6a15a3fe04f555c0480">TaskManager::resume</a> (tm_taskId_t taskId)</td></tr>
<tr class="memdesc:ga1bf8c3e66349d6a15a3fe04f555c0480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume the given task on this node.  <a href="group___task_manager.html#ga1bf8c3e66349d6a15a3fe04f555c0480">More...</a><br /></td></tr>
<tr class="separator:ga1bf8c3e66349d6a15a3fe04f555c0480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b88a62f061cbc8159a101844d8e5469"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___task_manager.html#ga2b88a62f061cbc8159a101844d8e5469">TaskManager::loop</a> ()</td></tr>
<tr class="memdesc:ga2b88a62f061cbc8159a101844d8e5469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a single pass for the system <a class="el" href="group___task_manager.html#ga2b88a62f061cbc8159a101844d8e5469" title="Implements a single pass for the system loop() routine.">loop()</a> routine.  <a href="group___task_manager.html#ga2b88a62f061cbc8159a101844d8e5469">More...</a><br /></td></tr>
<tr class="separator:ga2b88a62f061cbc8159a101844d8e5469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9968aa8e895bfc0bbb0cd4e06ee14e6d"><td class="memItemLeft" align="right" valign="top">_TaskManagerTask *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___task_manager.html#ga9968aa8e895bfc0bbb0cd4e06ee14e6d">TaskManager::findTaskById</a> (tm_taskId_t id)</td></tr>
<tr class="memdesc:ga9968aa8e895bfc0bbb0cd4e06ee14e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a task by its ID. <br  />
  <a href="group___task_manager.html#ga9968aa8e895bfc0bbb0cd4e06ee14e6d">More...</a><br /></td></tr>
<tr class="separator:ga9968aa8e895bfc0bbb0cd4e06ee14e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09bb6c7863e8d8f3744b8d6da95a56bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___task_manager.html#ga09bb6c7863e8d8f3744b8d6da95a56bf">TaskManager::internalSendMessage</a> (tm_nodeId_t fromNodeId, tm_taskId_t fromTaskId, tm_taskId_t taskId, char *message)</td></tr>
<tr class="memdesc:ga09bb6c7863e8d8f3744b8d6da95a56bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a string message to a task on this system. Send a null-terminated (string) message to a task running on this system. This is the internal gateway used by both sendMessage("this node") and from the radio receiver module (messages from other nodes).  <a href="group___task_manager.html#ga09bb6c7863e8d8f3744b8d6da95a56bf">More...</a><br /></td></tr>
<tr class="separator:ga09bb6c7863e8d8f3744b8d6da95a56bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b702e8ce9d59865dcc6b58742b8254b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___task_manager.html#ga1b702e8ce9d59865dcc6b58742b8254b">TaskManager::internalSendMessage</a> (tm_nodeId_t fromNodeId, tm_taskId_t fromTaskId, tm_taskId_t taskId, void *buf, int len)</td></tr>
<tr class="memdesc:ga1b702e8ce9d59865dcc6b58742b8254b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a binary message to a task on this system. Send a raw data (binary) message to a task running on this system. This is the internal gateway used by both sendMessage("this node") and from the radio receiver module (messages from other nodes).  <a href="group___task_manager.html#ga1b702e8ce9d59865dcc6b58742b8254b">More...</a><br /></td></tr>
<tr class="separator:ga1b702e8ce9d59865dcc6b58742b8254b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab797d73ccb1b1a13c797bd1262249dea"><td class="memItemLeft" align="right" valign="top">tm_nodeId_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___task_manager.html#gab797d73ccb1b1a13c797bd1262249dea">TaskManager::myNodeId</a> ()</td></tr>
<tr class="memdesc:gab797d73ccb1b1a13c797bd1262249dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the node ID of this system.  <a href="group___task_manager.html#gab797d73ccb1b1a13c797bd1262249dea">More...</a><br /></td></tr>
<tr class="separator:gab797d73ccb1b1a13c797bd1262249dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga3b61b260f5ddd9676f7a6899da40ad9e" name="ga3b61b260f5ddd9676f7a6899da40ad9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b61b260f5ddd9676f7a6899da40ad9e">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::add </td>
          <td>(</td>
          <td class="paramtype">tm_taskId_t&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a simple task. </p>
<p >The task will execute once each cycle through the task list. Unless the task itself forces itself into a different scheduling model (e.g., through YieldSignal), it will execute again at the next available opportunity </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [1 239]. System tasks have taskId values in the range [240 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___task_manager.html#gad0d87e94ca41ece59e98adba02ba8103" title="Add a task that will be delayed before its first invocation.">addWaitDelay</a>, <a class="el" href="group___task_manager.html#gaef8ccd8e7753e35a483dd8d9203ef8ca" title="Add a task that will be delayed until a set system clock time before its first invocation.">addWaitUntil</a>, <a class="el" href="group___task_manager.html#ga41d58e9b9e596b19264bb2cbf7c02878" title="Add a task that will automatically reschedule itself with a delay.">addAutoWaitDelay</a> </dd></dl>

</div>
</div>
<a id="ga41d58e9b9e596b19264bb2cbf7c02878" name="ga41d58e9b9e596b19264bb2cbf7c02878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41d58e9b9e596b19264bb2cbf7c02878">&#9670;&nbsp;</a></span>addAutoWaitDelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::addAutoWaitDelay </td>
          <td>(</td>
          <td class="paramtype">tm_taskId_t&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startDelayed</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task that will automatically reschedule itself with a delay. </p>
<p >This task will execute once each cycle. The task will automatically reschedule itself to not execute until the given delay has passed. The first execution may be delayed using the optional fourth parameter startDelayed. This delay, if used, will be the same as the period.</p>
<p >Note that yielding for messages or signals may extend this delay. However, if a signal/message is received during the delay period., the procedure will still wait until the end of the delay period. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
    <tr><td class="paramname">period</td><td>&ndash; the schedule, in milliseconds </td></tr>
    <tr><td class="paramname">startDelayed</td><td>&ndash; for the first execution, start immediately (false), or delay its start for one period (true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___task_manager.html#ga3b61b260f5ddd9676f7a6899da40ad9e" title="Add a simple task.">add</a>, addDelayed, <a class="el" href="group___task_manager.html#gaef8ccd8e7753e35a483dd8d9203ef8ca" title="Add a task that will be delayed until a set system clock time before its first invocation.">addWaitUntil</a> </dd></dl>

</div>
</div>
<a id="ga2c4cd56685a46a66bb3b5a25c1ba8685" name="ga2c4cd56685a46a66bb3b5a25c1ba8685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c4cd56685a46a66bb3b5a25c1ba8685">&#9670;&nbsp;</a></span>addAutoWaitMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::addAutoWaitMessage </td>
          <td>(</td>
          <td class="paramtype">tm_taskId_t&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startWaiting</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task that is waiting for a message or until a timeout occurs. </p>
<p >The task will be added, but will be set to be waiting for the listed signal. If the signal does not arrive before the timeout period (in milliseconds), then the routine will be activated. The routine may use <a class="el" href="group__receive.html#gae7641b79a5efb0a5e640daa8f623fa5c" title="Tell if the current task has timed out while waiting for a signal or message.">TaskManager::timedOut()</a> to determine whether it timed our or received the signal. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
    <tr><td class="paramname">timeout</td><td>&ndash; the maximum time to wait (in ms) before timing out. </td></tr>
    <tr><td class="paramname">startWaiting</td><td>&ndash; tells whether the routine will start waiting for the signal (true) or will execute immediately (false). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___task_manager.html#ga51b5017ee459e0d54a0995c084bd273f" title="Add a task that is waiting for a message.">addWaitMessage</a> </dd></dl>

</div>
</div>
<a id="gad0d87e94ca41ece59e98adba02ba8103" name="gad0d87e94ca41ece59e98adba02ba8103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0d87e94ca41ece59e98adba02ba8103">&#9670;&nbsp;</a></span>addWaitDelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::addWaitDelay </td>
          <td>(</td>
          <td class="paramtype">tm_taskId_t&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>msDelay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task that will be delayed before its first invocation. </p>
<p >This task will execute once each cycle. Its first execution will be delayed for a set time. After this, unless the task forces itself into a different scheduling model (e.g., through yieldSignal), it will execute agaion at the next available opportunity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
    <tr><td class="paramname">msDelay</td><td>&ndash; the initial delay, in milliseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___task_manager.html#ga3b61b260f5ddd9676f7a6899da40ad9e" title="Add a simple task.">add</a>, <a class="el" href="group___task_manager.html#gaef8ccd8e7753e35a483dd8d9203ef8ca" title="Add a task that will be delayed until a set system clock time before its first invocation.">addWaitUntil</a>, <a class="el" href="group___task_manager.html#ga41d58e9b9e596b19264bb2cbf7c02878" title="Add a task that will automatically reschedule itself with a delay.">addAutoWaitDelay</a> </dd></dl>

</div>
</div>
<a id="ga51b5017ee459e0d54a0995c084bd273f" name="ga51b5017ee459e0d54a0995c084bd273f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51b5017ee459e0d54a0995c084bd273f">&#9670;&nbsp;</a></span>addWaitMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::addWaitMessage </td>
          <td>(</td>
          <td class="paramtype">tm_taskId_t&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task that is waiting for a message. </p>
<p >The task will be added, but will be waiting for a message. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
    <tr><td class="paramname">timeout</td><td>&ndash; the maximum time to wait (in ms) before timing out. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaef8ccd8e7753e35a483dd8d9203ef8ca" name="gaef8ccd8e7753e35a483dd8d9203ef8ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef8ccd8e7753e35a483dd8d9203ef8ca">&#9670;&nbsp;</a></span>addWaitUntil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::addWaitUntil </td>
          <td>(</td>
          <td class="paramtype">tm_taskId_t&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>msWhen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a task that will be delayed until a set system clock time before its first invocation. </p>
<p >This task will execute once each cycle. Its first execution will be delayed until a set system clock time. After this, unless the task forces itself into a different scheduling model (e.g., through yieldSignal), it will execute agaion at the next available opportunity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>- the task's ID. For normal user tasks, this should be a byte value in the range [0 127]. System tasks have taskId values in the range [128 255]. </td></tr>
    <tr><td class="paramname">fn</td><td>&ndash; this is a void function with no arguments. This is the procedure that is called every time the task is invoked. </td></tr>
    <tr><td class="paramname">msWhen</td><td>&ndash; the initial delay, in milliseconds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___task_manager.html#ga3b61b260f5ddd9676f7a6899da40ad9e" title="Add a simple task.">add</a>, <a class="el" href="group___task_manager.html#gad0d87e94ca41ece59e98adba02ba8103" title="Add a task that will be delayed before its first invocation.">addWaitDelay</a>, <a class="el" href="group___task_manager.html#ga41d58e9b9e596b19264bb2cbf7c02878" title="Add a task that will automatically reschedule itself with a delay.">addAutoWaitDelay</a> </dd></dl>

</div>
</div>
<a id="ga9968aa8e895bfc0bbb0cd4e06ee14e6d" name="ga9968aa8e895bfc0bbb0cd4e06ee14e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9968aa8e895bfc0bbb0cd4e06ee14e6d">&#9670;&nbsp;</a></span>findTaskById()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_TaskManagerTask * TaskManager::findTaskById </td>
          <td>(</td>
          <td class="paramtype">tm_taskId_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a task by its ID. <br  />
 </p>
<p >This routine is for internal use only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>the ID of the task </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the _TaskManagerTask or NULL if not found </dd></dl>

</div>
</div>
<a id="ga09bb6c7863e8d8f3744b8d6da95a56bf" name="ga09bb6c7863e8d8f3744b8d6da95a56bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09bb6c7863e8d8f3744b8d6da95a56bf">&#9670;&nbsp;</a></span>internalSendMessage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::internalSendMessage </td>
          <td>(</td>
          <td class="paramtype">tm_nodeId_t&#160;</td>
          <td class="paramname"><em>fromNodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tm_taskId_t&#160;</td>
          <td class="paramname"><em>fromTaskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tm_taskId_t&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a string message to a task on this system. Send a null-terminated (string) message to a task running on this system. This is the internal gateway used by both sendMessage("this node") and from the radio receiver module (messages from other nodes). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromNodeId</td><td>- the source node of the message. 0 means "this node". </td></tr>
    <tr><td class="paramname">fromTaskId</td><td>- the source task of the message. </td></tr>
    <tr><td class="paramname">taskId</td><td>- which task is to receive the message. </td></tr>
    <tr><td class="paramname">message</td><td>- a null-terminated string message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1b702e8ce9d59865dcc6b58742b8254b" name="ga1b702e8ce9d59865dcc6b58742b8254b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b702e8ce9d59865dcc6b58742b8254b">&#9670;&nbsp;</a></span>internalSendMessage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::internalSendMessage </td>
          <td>(</td>
          <td class="paramtype">tm_nodeId_t&#160;</td>
          <td class="paramname"><em>fromNodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tm_taskId_t&#160;</td>
          <td class="paramname"><em>fromTaskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tm_taskId_t&#160;</td>
          <td class="paramname"><em>taskId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sends a binary message to a task on this system. Send a raw data (binary) message to a task running on this system. This is the internal gateway used by both sendMessage("this node") and from the radio receiver module (messages from other nodes). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromNodeId</td><td>- the source node of the message. 0 means "this node". </td></tr>
    <tr><td class="paramname">fromTaskId</td><td>- the source task of the message. </td></tr>
    <tr><td class="paramname">taskId</td><td>- which task is to receive the message. </td></tr>
    <tr><td class="paramname">buf</td><td>- the buffer with the message. </td></tr>
    <tr><td class="paramname">len</td><td>- the size of the buf (in bytes). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2b88a62f061cbc8159a101844d8e5469" name="ga2b88a62f061cbc8159a101844d8e5469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b88a62f061cbc8159a101844d8e5469">&#9670;&nbsp;</a></span>loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::loop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements a single pass for the system <a class="el" href="group___task_manager.html#ga2b88a62f061cbc8159a101844d8e5469" title="Implements a single pass for the system loop() routine.">loop()</a> routine. </p>
<p >This performs a single iteration for the system <a class="el" href="group___task_manager.html#ga2b88a62f061cbc8159a101844d8e5469" title="Implements a single pass for the system loop() routine.">loop()</a> routine. It finds the next runnable task and runs it. It processes any yield*() operations that the user routine may have executed.</p>
<p >This routine is for internal use only. </p>

</div>
</div>
<a id="gab797d73ccb1b1a13c797bd1262249dea" name="gab797d73ccb1b1a13c797bd1262249dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab797d73ccb1b1a13c797bd1262249dea">&#9670;&nbsp;</a></span>myNodeId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tm_nodeId_t TaskManager::myNodeId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the node ID of this system. </p>
<dl class="section return"><dt>Returns</dt><dd>The byte value that is the current node's radio ID. If the radio has not been enabled, returns 0. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This routine is only available on ESP environments. </dd></dl>

</div>
</div>
<a id="ga1bf8c3e66349d6a15a3fe04f555c0480" name="ga1bf8c3e66349d6a15a3fe04f555c0480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bf8c3e66349d6a15a3fe04f555c0480">&#9670;&nbsp;</a></span>resume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TaskManager::resume </td>
          <td>(</td>
          <td class="paramtype">tm_taskId_t&#160;</td>
          <td class="paramname"><em>taskId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume the given task on this node. </p>
<p >Resumes a task. If the task do not exist, nothing happens. If the task had not been suspended, nothing happens. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>The task to be resumed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the task could be resumed, false otherwise</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Not implemented. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___task_manager.html#ga0b85b2e38baa808ad06b039adff9142c" title="Suspend the given task on this node.">suspend()</a> </dd></dl>

</div>
</div>
<a id="ga0b85b2e38baa808ad06b039adff9142c" name="ga0b85b2e38baa808ad06b039adff9142c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b85b2e38baa808ad06b039adff9142c">&#9670;&nbsp;</a></span>suspend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TaskManager::suspend </td>
          <td>(</td>
          <td class="paramtype">tm_taskId_t&#160;</td>
          <td class="paramname"><em>taskId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend the given task on this node. </p>
<p >The given task will be suspended until it is resumed. It will not be allowed to run, nor will it receive messages or signals. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskId</td><td>The task to be suspended </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the task could be suspended, false otherwise </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__receive.html">Receiving Messages</a> </dd></dl>

</div>
</div>
<a id="ga491dc7a77a5381675f614a411755ef64" name="ga491dc7a77a5381675f614a411755ef64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga491dc7a77a5381675f614a411755ef64">&#9670;&nbsp;</a></span>TaskManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TaskManager::TaskManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor, Creates an empty task. </p>
<p >Print out information about the task. </p>

</div>
</div>
<a id="gabc4f2e57cdc1fd1d3051b58dc816de98" name="gabc4f2e57cdc1fd1d3051b58dc816de98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc4f2e57cdc1fd1d3051b58dc816de98">&#9670;&nbsp;</a></span>yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::yield </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit from this task and return control to the task manager. </p>
<p >This exits from the current task, and returns control to the task manager. Functionally, it is similar to a return statement. The next time the task gains control, it will resume from the TOP of the routine. Note that if the task was an Auto task, it will be automatically rescheduled according to its Auto specifications. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___task_manager.html#ga2123fa0af84c3a1373b9437e2157e872" title="Exit from the task manager and do not restart this task until after a specified period.">yieldDelay()</a>, <a class="el" href="group___task_manager.html#gaa3f827ee35d80bc4faa2f7d438163e78" title="Exit from the task manager and do not restart this task until (after) a specified CPU clock time.">yieldUntil()</a>, yieldSignal(), yieldMessage(), <a class="el" href="group___task_manager.html#ga41d58e9b9e596b19264bb2cbf7c02878" title="Add a task that will automatically reschedule itself with a delay.">addAutoWaitDelay()</a>, addAutoWaitSignal(), <a class="el" href="group___task_manager.html#ga2c4cd56685a46a66bb3b5a25c1ba8685" title="Add a task that is waiting for a message or until a timeout occurs.">addAutoWaitMessage()</a> </dd></dl>

</div>
</div>
<a id="ga2123fa0af84c3a1373b9437e2157e872" name="ga2123fa0af84c3a1373b9437e2157e872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2123fa0af84c3a1373b9437e2157e872">&#9670;&nbsp;</a></span>yieldDelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::yieldDelay </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit from the task manager and do not restart this task until after a specified period. </p>
<p >This exits from the current task and returns control to the task manager. This task will not be rescheduled until at least the stated number of milliseconds has passed. Note that yieldDelay <em>overrides</em> any of the Auto specifications. That is, the next rescheduling will occur <em>solely</em> after the stated time period, and will not be constrained by AutoWaitSignal, AutoWaitMessage, or a different AutoWaitDelay value. The Auto specification will be retained, and will be applied on future executions where <a class="el" href="group___task_manager.html#gabc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager.">yield()</a> or a normal return are used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>&ndash; the delay in milliseconds. Note the next call may exceed this constraint depending on time taken by other tasks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___task_manager.html#gabc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager.">yield()</a>, <a class="el" href="group___task_manager.html#gaa3f827ee35d80bc4faa2f7d438163e78" title="Exit from the task manager and do not restart this task until (after) a specified CPU clock time.">yieldUntil()</a>, yieldSignal(), yieldMessage(), <a class="el" href="group___task_manager.html#ga41d58e9b9e596b19264bb2cbf7c02878" title="Add a task that will automatically reschedule itself with a delay.">addAutoWaitDelay()</a>, addAutoWaitSignal(), <a class="el" href="group___task_manager.html#ga2c4cd56685a46a66bb3b5a25c1ba8685" title="Add a task that is waiting for a message or until a timeout occurs.">addAutoWaitMessage()</a> </dd></dl>

</div>
</div>
<a id="ga4f368a9141c55b085aefdc8833aeaeec" name="ga4f368a9141c55b085aefdc8833aeaeec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f368a9141c55b085aefdc8833aeaeec">&#9670;&nbsp;</a></span>yieldForMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::yieldForMessage </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit from the task manager and do not restart this task until a message has been received or a stated time period has passed. </p>
<p >This exits from the current task and returns control to the task manager. This task will not be rescheduled until a message has been received or a stated time period has passed (the timeout period). The TaskManager::timeOut() function will tell whether or not the timeout had been triggered.</p>
<dl class="section note"><dt>Note</dt><dd>The yieldForMessage call <em>overrides</em> any of the Auto specifications. That is, the next rescheduling will occur <em>solely</em> after the signal has been received, and will not be constrained by AutoWaitDelay, AutoWaitSignal, or a different AutoWaitMessage value. The Auto specification will be retained, and will be applied on future executions where <a class="el" href="group___task_manager.html#gabc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager.">yield()</a> or a normal return are used. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>&ndash; The timeout period, in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___task_manager.html#gabc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager.">yield()</a>, <a class="el" href="group___task_manager.html#ga2123fa0af84c3a1373b9437e2157e872" title="Exit from the task manager and do not restart this task until after a specified period.">yieldDelay()</a>, yieldForSignal(), <a class="el" href="group___task_manager.html#ga41d58e9b9e596b19264bb2cbf7c02878" title="Add a task that will automatically reschedule itself with a delay.">addAutoWaitDelay()</a>, addAutoWaitSignal(), <a class="el" href="group___task_manager.html#ga2c4cd56685a46a66bb3b5a25c1ba8685" title="Add a task that is waiting for a message or until a timeout occurs.">addAutoWaitMessage()</a>, timeOut() </dd></dl>

</div>
</div>
<a id="gaa3f827ee35d80bc4faa2f7d438163e78" name="gaa3f827ee35d80bc4faa2f7d438163e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3f827ee35d80bc4faa2f7d438163e78">&#9670;&nbsp;</a></span>yieldUntil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskManager::yieldUntil </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>when</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exit from the task manager and do not restart this task until (after) a specified CPU clock time. </p>
<p >This exits from the current task and returns control to the task manager. This task will not be rescheduled until the CPU clock (millis()) has exceeded the given time. Note that yieldUntil <em>overrides</em> any of the Auto specifications. That is, the next rescheduling will occur <em>solely</em> after the stated clock time has passed, and will not be constrained by AutoWaitSignal, AutoWaitMessage, or a different AutoWaitDelay value. The Auto specification will be retained, and will be applied on future executions where <a class="el" href="group___task_manager.html#gabc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager.">yield()</a> or a normal return are used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">when</td><td>&ndash; The target CPU time. Note the next call may exceed this constraint depending on time taken by other tasks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___task_manager.html#gabc4f2e57cdc1fd1d3051b58dc816de98" title="Exit from this task and return control to the task manager.">yield()</a>, <a class="el" href="group___task_manager.html#ga2123fa0af84c3a1373b9437e2157e872" title="Exit from the task manager and do not restart this task until after a specified period.">yieldDelay()</a>, yieldSignal(), yieldMessage(), <a class="el" href="group___task_manager.html#ga41d58e9b9e596b19264bb2cbf7c02878" title="Add a task that will automatically reschedule itself with a delay.">addAutoWaitDelay()</a>, addAutoWaitSignal(), <a class="el" href="group___task_manager.html#ga2c4cd56685a46a66bb3b5a25c1ba8685" title="Add a task that is waiting for a message or until a timeout occurs.">addAutoWaitMessage()</a> </dd></dl>

</div>
</div>
<a id="ga6ecdd2b8a6b7545eae64da180ba80c53" name="ga6ecdd2b8a6b7545eae64da180ba80c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ecdd2b8a6b7545eae64da180ba80c53">&#9670;&nbsp;</a></span>~TaskManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TaskManager::~TaskManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. Destroys the <a class="el" href="class_task_manager.html" title="A cooperative multitasking manager.">TaskManager</a>. </p>
<p >After calling this, any operations based on the object will fail. For normal purpoases, destroying the TaskMgr instance will have serious consequences for the standard <a class="el" href="group___task_manager.html#ga2b88a62f061cbc8159a101844d8e5469" title="Implements a single pass for the system loop() routine.">loop()</a> routine. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jul 5 2022 13:15:22 for TaskManager by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
